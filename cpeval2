#!/usr/bin/perl

my $pod_data = << 'END_POD';
=head1 NAME

cpeval2

=head1 DESCRIPTION

Checks account and configuration information on third-party (non-cPanel) source and cPanel destination servers, performs a configuration comparison, and outputs a form ready for sending to a customer to explain any required or recommended changes.

=head1 SYNOPSIS

=for comment
Keep the usage() sub in sync with the options here.
=end comment

=over

=item Mode 1:

B<cpeval2>

=back

=over

=item Mode 2:

B<cpeval2> S<I<INPUTFILE>>

B<cpeval2> S<B<--es> I<INPUTFILE>>

=back

=over

=item Other:

B<cpeval2> S<B<--create-keys>>

B<cpeval2> S<B<--updateuserdomains>>

B<cpeval2> S<B<--full-help>>

=back

=head1 DEFINITIONS

=over

=item C<INPUTFILE>

An input file is a text file containing cpeval2 prefixed output from "Mode 1" on both source and destination servers, concatenated into a single file.  The prefixed output begins with "s:" for the source server, and "d:" for the destination server.

=back

=head1 FLAGS

=over

=item B<--create-keys>

For use only on a destination (cPanel) server.  Creates a unique SSH key-pair to be used for a dedicated migration user account on the source server, and provides copy/paste output that can be executed on the source server to create the account.  It is automatically used the first time you run cpeval2 on a cPanel server.

=item B<--updateuserdomains>

For use only on a third-party source (non-cPanel) server.  Downloads and executes the updateuserdomains-universal script to populate /etc/trueuserdomains.

=item B<--es>

For use only with "Mode 2", this provides output in Spanish.

=back

=head1 EXAMPLES

=over

=item Run cpeval2 for the first time on a source or destination server (Mode 1):

B<cpeval2>

=item Run cpeval2 after "Mode 1" prefixed output from both servers has been copied into "cpeval2-compare.txt":

B<cpeval2 cpeval2-compare.txt>

=item Run cpeval2 after "Mode 1" prefixed output from both servers has been copied into "cpeval2-compare.txt", and provide the output in Spanish:

B<cpeval2 --es cpeval2-compare.txt>

=item Download and run the updateuserdomains-universal script:

B<cpeval2 --updateuserdomains>

=back

=head1 COPYRIGHT

This software is Copyright 2015 by cPanel, Inc.

THE SOFTWARE LICENSED HEREUNDER IS PROVIDED "AS IS" AND CPANEL HEREBY DISCLAIMS ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, RELATING TO THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, OR THE ACCURACY, TIMELINESS, COMPLETENESS, OR ADEQUACY OF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, AND ANY DATA ACCESSED THEREFROM, INCLUDING THE IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, SATISFACTORY QUALITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  CPANEL DOES NOT WARRANT THAT THE SOFTWARE OR ITS THIRD PARTY COMPONENTS ARE ERROR-FREE OR WILL OPERATE WITHOUT INTERRUPTION.  IF THE SOFTWARE, ITS THIRD PARTY COMPONENTS, OR ANY DATA ACCESSED THEREFROM IS DEFECTIVE, YOU ASSUME THE SOLE RESPONSIBILITY FOR THE ENTIRE COST OF ALL REPAIR OR INJURY OF ANY KIND, EVEN IF CPANEL HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DEFECTS OR DAMAGES.  NO ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY CPANEL, ITS AFFILIATES, LICENSEES, DEALERS, SUB-LICENSORS, AGENTS OR EMPLOYEES SHALL CREATE A WARRANTY OR IN ANY WAY.

=cut
END_POD

# ADDING CHECKS
# There are 4 things that need to be done. Using the PHP check as an example:

# When run WITHOUT an input file (e.g., lwp-request x.x.x.x/cpeval2 | perl):

    # (1) print_php_info()            # prints PHP: 5.3.24
    # (2) print_prefixed_php_info()   # prints s:Ensim:PHP:5.1


# When run WITH an input file (e.g., ./cpeval2 outfile):

    # (3) parse_output_file()
    # (4) print_parsed_php_info( $src_php, $dst_php )



use strict;
use warnings;
use Getopt::Long;
use IPC::Open3;
use IO::Socket::INET;
use Pod::Usage;
use POSIX qw( strftime );
use Term::ANSIColor qw(:constants);
$Term::ANSIColor::AUTORESET = 1;

my $version = '1.31';

my $opts = opts_get();

create_cpmig_user() if $opts->{'createuser'};

my $DEBUG              = 0;

my $panel_regex = 's:(?:Plesk(?:8|9|10|10SMB|11|12)|Ensim|DirectAdmin)';

my $prefix;                 # d: or s:Plesk9 or s:DirectAdmin, etc.
my $apache_bin;
my $python_bin;

my $is_cpanel       = 0;
my $is_plesk        = 0;
my $is_plesk_smb10  = 0;
my $is_ensim        = 0;
my $is_da           = 0;

my $src_panel;              # Ensim, DirectAdmin, Plesk8, Plesk9, Plesk10, Plesk10SMB, Plesk11, Plesk12
my $src_panel_noversion;    # Ensim, DirectAdmin, Plesk
my $src_panel_version;      # e.g. "Plesk 12.0.18"

my $dst_panel_version;      # e.g. "cPanel 11.44.0.18"

my $cpanel_version;         # e.g. "11.44.0.18"

my ( @hosting_type_forward, @hosting_type_nohosting );
my @plesk_reseller_username_conflicts;

my $has_pgsql = 0;
my $eula_accepted = 0;

my ( $plesk_major_version, $plesk_minor_version );

my @badusers;               # if mysql username conflicts are detected, skip any bad users since they need renaming anyway

get_control_panel_and_set_prefix();
verify_mysql_connectivity();

my $ticket = get_ticket();
my $cpmiguser = 'cpmig' . $ticket;

if ($opts->{'createkeys'}) {
    die "create-keys should only be run on the cPanel destination host.\n" unless $is_cpanel;
    create_cpmig_keypair($cpmiguser, $ticket);
    exit;
}

if ($opts->{'updateuserdomains'}) {
    die "cpeval2 --updateuserdomains is only for non-cPanel servers.\nUse /scripts/updateuserdomains instead.\n" if $is_cpanel;
}

## behave like the original cpeval
if ( !$opts->{'inputfile'} ) {
    check_trueuserdomains();
    print_control_panel_info();
    print_os_info();
    print_perl_info();
    print_mysql_info();
    print_php_info();
    print_apache_info();
    print_cpu_info();
    print_mem_info();
    print_number_of_accounts();
    print_dedicated_ipaddrs();
    print_mysql_db_count();
    print_postgres_db_count();
    check_destination_var_usage();
    print_duplicate_usernames();
    print_custom_apache_modules();
    print_custom_php_modules();
    print_htype_fwd();
    print_htype_none();
    print_plesk_duplicate_email_users();
    print_reseller_username_conflicts();

    print '-' x 40 . "\n";

    print_prefixed_panel_info();
    print_prefixed_php_info();
    print_prefixed_mysql_info();
    print_prefixed_bad_username_info(); # this sub MUST come before print_mysql_username_conflict_info();
    print_prefixed_dedicated_ip_addr_info();
    print_prefixed_hosting_types();
    print_prefixed_tomcat_info();
    print_prefixed_coldfusion_info();
    print_prefixed_reseller_username_conflicts();
    print_prefixed_user_config_problems();
    print_prefixed_php_information();
    print_prefixed_cpanel_eula_accepted_check();
    print_prefixed_mysql_username_conflict_info();
    print_prefixed_mysql_openfileslimit();
    print_prefixed_mysql_skip_networking();
    print_prefixed_mysql_old_style_passwords_info();

}
## parse output file; this prints info we can just copy/paste into the ticket
else {
    parse_output_file( $opts->{'inputfile'} );
}

unless ( $opts->{'inputfile'} ) {
    print_header('DISK SPACE');
    print "Please review this output now, compare with the output from the other server, and check for possible issues:\n\n";
    print `df -Ph | column -t | head -1 ; df -Ph | column -t | sort | uniq | egrep -v '^Filesystem|/var/named/run-root/var/run/dbus|/var/named/chroot|/usr/local/psa/handlers/|/virtfs/| /tmp\$'`;
    print "\nA few things to keep in mind are:\n";
    print "  * pkgacct-* packages accounts in /home . Is /home on /, or is it separate?\n";
    print "  * Need to change the partition that accounts are packaged to? Check the 'MigrationsReference' article\n";
    print "  * Is more space being used on the source than what is available on the destination?\n";
    print "  * If there's, say, 50GB free on the source, the largest account that can be copied is a little less than 25GB (half of 50)\n";

    if ( $is_plesk == 1 ) {
        print "  * Plesk stores users' data under /var [ /var/www/vhosts/\${DOMAIN}/ ] [ /var/qmail/mailnames/\${DOMAIN}/ ] [ /var/lib/mysql ]\n";
        if ( $^O =~ /freebsd/i ) {
            print "  * commonly, customers with FreeBSD will have different locations for their services\n" .
                  "  * if pkgacct fails to find the locations of the user's data, you will need to get the locations of the data from /etc/psa/psa.conf, then create directories and symlinks so pkgacct can package correctly\n" .
                  "  * variables to grep for in the psa.conf are HTTPD_VHOSTS_D, QMAIL_MAILNAMES_D, MYSQL_VAR_D, PGSQL_DATA_D\n";
        }
    }
}

if ( $is_cpanel == 1 and -f '/var/cpanel/transfers_devel' ) {
    print "\n\n!! /var/cpanel/transfers_devel exists! Server may be using _DEVEL migrations scripts !!\n";
}

# for libkeyutils malware migrations
if ( $is_cpanel == 1 ) {
    check_for_ssl_certificates();
    check_for_dns_clustering();
}

unless ( $opts->{'inputfile'} ) {
    if ( $is_cpanel == 1 ) {
        my $mailutil_missing_libs = 0; 

        if ( -e '/usr/bin/ldd' and -x '/usr/bin/ldd' ) {
            if ( my @ldd_mailutil = `ldd /usr/local/cpanel/Whostmgr/Pkgacct/3rdparty/mbx2mbox/mailutil` ) {
                for my $line (@ldd_mailutil) {
                    chomp $line;
                    if ( $line =~ /not found/ ) {
                        $mailutil_missing_libs = 1; 
                    }    
                }    

                if ( $mailutil_missing_libs == 1 ) {
                    print_header('Ensim');
                    print "/u/l/c/Whostmgr/Pkgacct/3rdparty/mbx2mbox/mailutil is missing libs (use 'ldd' to see which are missing)\n";
                    print "Copying accounts from Ensim? Check FB 72981 first! Email may not get copied properly otherwise.\n";
                }    
            }
        }
    }    
}


submit_stats_info();

check_for_missing_scp();

auto_create_keypair($cpmiguser, $ticket) unless $opts->{'inputfile'};

##########


sub version_cmp { # should only be used by version_compare()
    my ( $parent1, $major1, $minor1, $build1 ) = split /[\._]/, $_[0];
    my ( $parent2, $major2, $minor2, $build2 ) = split /[\._]/, $_[1];
    return $parent1 <=> $parent2 || $major1 <=> $major2 || $minor1 <=> $minor2 || $build1 <=> $build2;
}

sub version_compare {
    # example: return if version_compare($ver_string, qw( >= 1.2.3.3 ));
    # Must be a four-digit version separated by periods.
    my ($ver1, $mode, $ver2) = @_;
  # Shamelessly copied the comparison logic out of Cpanel::Version::Compare
    my %modes = (
        '>' => sub {
              return if $_[0] eq $_[1];
              return version_cmp(@_) > 0;
          },
          '<' => sub {
              return if $_[0] eq $_[1];
              return version_cmp(@_) < 0;
          },
          '==' => sub { return $_[0] eq $_[1] || version_cmp(@_) == 0; },
          '!=' => sub { return $_[0] ne $_[1] && version_cmp(@_) != 0; },
          '>=' => sub {
              return 1 if $_[0] eq $_[1];
              return version_cmp(@_) >= 0;
          },
          '<=' => sub {
              return 1 if $_[0] eq $_[1];
              return version_cmp(@_) <= 0;
         }
    );
    return if ( ! exists $modes{$mode} );
    return $modes{$mode}->( $ver1, $ver2 );
}

sub print_news_cpanel {
    print q{};
}

sub print_news_plesk {
#    print q{   !! PLESK BLOCKERS !!
#    };
#
#    sleep 3;
}

sub print_news_ensim {
     # No current blockers listed.  Last removed was Case 107517.
}

sub print_news_da {
#    print q{   !! DA BLOCKERS !!
#    };
#
#    sleep 3;
}


sub mysql_test {
    my $mysql_output = `mysql -e 'select 1' 2>&1`;
    return $mysql_output;
}

sub print_header {
    my $text = shift;
    print "\n" . '=' x 50 . "\n$text\n" . '=' x 50 . "\n";
}


## determine the control panel, and set the prefix
sub get_control_panel_and_set_prefix {
    # CPANEL
    if ( -f '/usr/local/cpanel/cpanel' ) {
        $prefix = 'd:';
        $is_cpanel = 1;
    }
    # PLESK
    elsif ( -f '/usr/local/psa/version' ) {
        if ( -d '/etc/sw/keys/keys' ) {
            my @dir_contents;

            opendir( my $dir_fh, '/etc/sw/keys/keys' );
            @dir_contents = grep { ! /^\.(\.?)$/ } readdir $dir_fh;
            closedir $dir_fh;

            if ( @dir_contents ) {
                my $plesk_key = pop @dir_contents;

                open my $key_fh, '<', "/etc/sw/keys/keys/$plesk_key";
                while ( <$key_fh> ) {
                    if ( /Small Business Panel 10/ ) {
                        $prefix = 's:Plesk10SMB:';
                        $is_plesk_smb10 = 1;
                        last;
                    }
                }
                close $key_fh;
            }
        }

        if ( !$prefix ) {
            open my $psa_fh, '<', '/usr/local/psa/version';
            while ( <$psa_fh> ) {
                if ( m{ \A (\d+)\.(\d+)? }xms ) {
                    $plesk_major_version = $1;
                    $plesk_minor_version = $2 if $2;
                    if ($plesk_major_version == 11 and $plesk_minor_version and $plesk_minor_version >= 5) {
#                        print_plesk_version_unsupported( "${plesk_major_version}.${plesk_minor_version}" );
                    }

                    $prefix = 's:Plesk' . $plesk_major_version . ':';
                    $is_plesk = 1;
                }
            }
            close $psa_fh;
        }
    }
    # ENSIM
    elsif ( -f '/usr/bin/getapplversion' ) {
        $prefix = 's:Ensim:';
        $is_ensim = 1;
    }
    # DA
    elsif ( -f '/usr/local/directadmin/directadmin' ) {
        $prefix = 's:DirectAdmin:';
        $is_da = 1;
    }
    else {
        die "[!] Unknown control panel\n";
    }

    print_news_cpanel() if ( $is_cpanel == 1 );
    print_news_plesk()  if ( $is_plesk == 1 or $is_plesk_smb10 == 1 );
    print_news_ensim()  if ( $is_ensim == 1 );
    print_news_da()     if ( $is_da == 1 );
}

sub check_trueuserdomains {
    my $tud = '/etc/trueuserdomains';
    my $dip = '/etc/domainips';
    my $uudu = 'http://httpupdate.cpanel.net/cpanelsync/transfers_PUBLIC/pkgacct/updateuserdomains-universal';
    my $max_age = 30; #minutes
    my $skip_update = 0;

    if ( $is_cpanel == 0 ) {
        if ( -f $tud ) {
            my $age = int((time() - (stat(_))[9]) / 60);
            die("${tud} exists, but unable to determine modification time!\n\n") unless defined($age);
            if ( ! $opts->{'updateuserdomains'} and $age <= $max_age ){
                print "\n${tud} is less than ${max_age} minutes old, not auto-updating.\n";
                print "Use cpeval2 --updateuserdomains to force an update.\n";
                $skip_update = 1;
            }
        }
        if ( $opts->{'updateuserdomains'} or ! $skip_update ) {
            print "${tud} doesn't exist, is more than ${max_age} minutes old, or you forced an update.\n";
            print "\nDownloading and running updateuserdomains-universal via curl...\n";
            if ( system( 'curl -s ' . $uudu . ' | perl' ) != 0 ) {
                print "\nDownloading and running updateuserdomains-universal via wget...\n";
                if ( system( 'wget -q -O - ' . $uudu . ' | perl' ) != 0 ) {
                    print "\nFailed to download and run updateuserdomains-universal!\n";
                    sleep 2;
                }
            }
        }
        if ( -f $tud and -z _ ) {
            die "\n${tud} exists, but is empty!\n\n";
        }
    }
  
   if ( ! -f $tud or ! -f $dip ) { 
        die "\n${tud} OR ${dip} missing!\nUse updateuserdomains to generate them.\n\n";
    }

    print "\n";
}

sub check_destination_var_usage {
    return if $is_cpanel == 0;

    my $var_usage;
    open my $df_fh, '-|', '/bin/df', '-hP', '/var';
    while ( <$df_fh> ) {
        # Filesystem            Size  Used Avail Use% Mounted on
        # /dev/simfs             20G  6.2G   14G  31% /
        if ( m# \A /(?:\S+) \s+ ([0-9A-Z\.]+) \s+ ([0-9A-Z\.]+) \s+ ([0-9A-Z\.]+) \s+ ([0-9]+)% \s+ (\S+) #xms ) {
            $var_usage = "[Size: $1] [Used: $2] [Avail: $3] [Use%: $4] [Mount point: $5]\n";
        }
    }
    close $df_fh;

    if ($var_usage) {
        print_format( '/var', $var_usage );
    }
}

sub print_plesk_version_unsupported {
    my $plesk_version = shift;
    print "We're very sorry, but the Plesk server is using a version of Plesk that our migrations scripts do not support at this time ($plesk_version).\n\n";
    print "Our developers are actively working on support for this version of Plesk. We do not yet have an estimated time of completion.\n";
    print "Unfortunately, we will not be able to migrate the accounts at this time. We hope to see support for Plesk $plesk_version soon, and we appreciate your interest in cPanel!\n";
    exit;
}

sub verify_mysql_connectivity {
    my $mysql_output = mysql_test();
    if ( $mysql_output =~ /ERROR/ ) {
        # If /root/.my.cnf exists, take no action other than providing a hint as to what the issue may be
        if ( -e '/root/.my.cnf' ) {
            print "Could not connect to MySQL (query failed: mysql -e 'select 1').\n";
            print "/root/.my.cnf already exists. Inspect it manually.\n";

            if ( $is_plesk == 1 or $is_plesk_smb10 == 1 ) {
                print "Hint: try the password from /etc/psa/.psa.shadow and user 'admin'.\n";
            }    
            elsif ( $is_da == 1 ) {
                print "Hint: try the credentials from /usr/local/directadmin/conf/mysql.conf .\n";
            }    
            elsif ( $is_ensim == 1 ) {
                print "Hint: try with the user 'root' and the password from this command:\n";
                print 'ensim-python -c "import sys ; sys.path.append(\'/usr/lib/opcenter/mysql\') ; import mysqlbe ; print mysqlbe.read_mysqlpass()"' . "\n";
            }    
            elsif ( $is_cpanel == 1 ) {
                print "Hint: try with mysql user 'root' and the server's root password.\n";
            }    
            else {
                print "[!] Unable to determine control panel\n";
            }
            exit;
        }
        # If /root/.my.cnf does not exist, attempt to create it unless the server uses cPanel
        else {
            print "Could not connect to MySQL (/root/.my.cnf does not exist).";
            if ( $is_cpanel == 1 ) {
                print "\n";
            }
            else {
                print "Trying to create /root/.my.cnf now.\n";
            }
            umask 0077; # so /root/.my.cnf is 0600
            if ( $is_plesk == 1 or $is_plesk_smb10 == 1 ) {
                if ( -e '/etc/psa/.psa.shadow' ) {
                    open my $psa_fh, '<', '/etc/psa/.psa.shadow' or die "$!\n";
                    chomp(my $mysql_password = readline( $psa_fh ));
                    close $psa_fh;

                    if ( !$mysql_password ) {
                        die "Could not obtain mysql password from /etc/psa/.psa.shadow\n";
                    }
                    else {
                        open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                        print $mycnf_fh "[client]\nuser=admin\npassword=\"" . $mysql_password . "\"\n";
                        close $mycnf_fh;
                    }
                }
                else {
                    die "Attempted to obtain mysql password from /etc/psa/.psa.shadow, but it does not appear to exist\n";
                }
            }
            elsif ( $is_da == 1 ) {
                if ( -e '/usr/local/directadmin/conf/mysql.conf' ) {
                    open my $mysqlconf_fh, '<', '/usr/local/directadmin/conf/mysql.conf' or die "$!\n";

                    my $mysql_password;
                    while ( <$mysqlconf_fh> ) {
                        if ( m{ \A passwd=(.*) \z }xms ) {
                            chomp($mysql_password = $1);
                        }
                    }
                    close $mysqlconf_fh;

                    if ( !$mysql_password ) {
                        die "Could not obtain mysql password from /usr/local/directadmin/conf/mysql.conf\n";
                    }
                    else {
                        open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                        print $mycnf_fh "[client]\nuser=da_admin\npassword=\"" . $mysql_password . "\"\n";
                        close $mycnf_fh;
                    }
                }
                else {
                    die "Attempted to obtain mysql password from /usr/local/directadmin/conf/mysql.conf, but it does not appear to exist\n";
                }
            }
            elsif ( $is_ensim == 1 ) {
                chomp( my $mysql_password = `ensim-python -c "import sys ; sys.path.append('/usr/lib/opcenter/mysql') ; import mysqlbe ; print mysqlbe.read_mysqlpass()"` );
                if ( !$mysql_password ) {
                    die 'Unable to determine mysql pass via this command: ' .  "ensim-python -c \"import sys ; sys.path.append('/usr/lib/opcenter/mysql') ; import mysqlbe ; print mysqlbe.read_mysqlpass()\"\n";
                }
                else {
                    open my $mycnf_fh, '>', '/root/.my.cnf' or die "$!\n";
                    print $mycnf_fh "[client]\nuser=root\npassword=\"" . $mysql_password . "\"\n";
                    close $mycnf_fh;
                }
            }
            elsif ( $is_cpanel == 1 ) {
                die "You will need to manually create /root/.my.cnf\n";
            }
            else {
                die "[!] Unable to determine control panel\n";
            }

            # After creating /root/.my.cnf, see if we can connect to MySQL now. If not, remove our /root/.my.cnf and exit
            my $final_check = mysql_test();
            if ( $final_check =~ /ERROR/ ) {
                #unlink '/root/.my.cnf' or die "Could not remove our custom /root/.my.cnf\n";
                die "Still unable to connect to MySQL, even after creating /root/.my.cnf . Check contents of our custom /root/.my.cnf\n";
            }
            else {
                print "We can now connect to MySQL, proceeding.\n";
            }
        }
    }    
}

## print control panel version
sub print_control_panel_info {
    my $panel_version;

    if ( $is_cpanel ) {
        if ( open my $file_fh, '<', '/usr/local/cpanel/version' ) {
            chomp( $panel_version = readline $file_fh );
            close $file_fh;
        }

        if ( $panel_version ) {
            $src_panel_version = "cPanel " . $panel_version;
            $cpanel_version = $panel_version;
        }
        else {
            $src_panel_version = "cPanel (version unknown)";
        }
    }
    elsif ( $is_plesk or $is_plesk_smb10 ) {
        if ( open my $file_fh, '<', '/usr/local/psa/version' ) {
            while ( <$file_fh> ) {
                if ( m{ \A ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}) }xms ) {
                    $panel_version = $1;
                }
            }
            close $file_fh;
        }

        if ( $panel_version ) {
            $dst_panel_version = "Plesk " . $panel_version;
        }
        else {
            $dst_panel_version = "Plesk (version unknown)";
        }
    }
    elsif ( $is_ensim ) {
        my $panel_version = `/usr/bin/getapplversion` or die("Unable to discern Ensim version");
        $panel_version =~ /^([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})-.*$/;
        $panel_version = $1;

        if ( $panel_version ) {
            $dst_panel_version = "Ensim " . $panel_version;
        }
        else {
            $dst_panel_version = "Ensim (version unknown)";
        }
    }
    elsif ( $is_da ) {
        $panel_version = `/usr/local/directadmin/directadmin v` or die("Unable to discern DirectAdmin version");
        $panel_version =~ /^Version: DirectAdmin v.([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2})$/;
        $panel_version = $1; 

        if ( $panel_version ) {
            $dst_panel_version = "DirectAdmin " . $panel_version;
        }
        else {
            $dst_panel_version = "DirectAdmin (version unknown)";
        }
    }

    print "[ " . $dst_panel_version . " ]\n" if $dst_panel_version;
    print "[ " . $src_panel_version . " ]\n" if $src_panel_version;

}

sub print_os_info {
    my $os;
    
    if ( $^O =~ /linux/i ) {
        $os = 'Linux';
    }
    elsif ( $^O =~ /freebsd/i ) {
        $os = 'FreeBSD';
    }
    else {
        $os = 'Unknown';
    }

    if ( $os eq 'Linux' ) {
        my @release_files = qw(
            adamantix_version
            arch-release
            conectiva-release
            debian_release
            debian_version
            fedora-release
            gentoo-release
            immunix-release
            knoppix-version
            libranet_version
            mandrakelinux-release
            mandrake-release
            pardus-release
            redflag-release
            redhat-release
            redhat_version
            slackware-release
            slackware-version
            SuSE-release
            tinysofa-release
            trustix-release
            turbolinux-release
            va-release
            yellowdog-release
            yoper-release
        );

        for my $release_file ( @release_files ) {
            if ( -e '/etc/' . $release_file ) {
                $release_file =~ s/release//g;
                $release_file =~ s/version//g;
                $release_file =~ s/[-_]//g;

                if ( $release_file eq 'redhat' ) {
                    $release_file = 'Redhat/CentOS';
                }
                $os .= " ($release_file)";

                last;
            }
        }
    }

#    print 'OS: ' . "$os\n";
    print_format( 'OS', $os );
}

sub print_format {
    my ( $str1, $str2 ) = @_;
    format =
@>>>>>>>>>>>>>>>>>>>> @< @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$str1, ':', $str2
.

    write;
}
        

sub print_perl_info {
    # Previously read in output from 'perl -v', then tried to use $^V, but these proved to be unreliable.
    my $perl_version = $];
    if ( $perl_version && $perl_version =~ /^(\d+)\.(\d{3})(\d{3})/ ) {
        $perl_version = join ('.', ($1 + 0), ($2 + 0), ($3 + 0));
    }

    if ( !$perl_version ) {
        $perl_version = 'Unknown';
    }
    else {
        if ( version_compare( $perl_version, qw( < 5.6.2.0 ) ) ) {
            $perl_version = $perl_version . ' [ PERL MUST BE 5.6.2+ ]';
        }
    }

    print_format( 'Perl', $perl_version );
}

sub print_mysql_info {
    my $mysql_version = `mysql --version`;
    $mysql_version =~ /Ver [0-9]{1,2}\.[0-9]{1,2} Distrib ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}[a-z]?), for/;
    $mysql_version = $1 ? $1 : 'Unknown';

    if ( $mysql_version ne 'Unknown' ) {
        my $mysql_version_tmp = $mysql_version;
        $mysql_version_tmp =~ s/\.//g;
        $mysql_version_tmp = substr $mysql_version_tmp, 0, 2;

        if ( $mysql_version_tmp < 41 ) {
            $mysql_version .= " :UNSUPPORTED\n";
        }
    }

#    print 'MySQL: ' . "$mysql_version\n";
    print_format( 'MySQL', $mysql_version );
}

sub print_php_info {
    my $php_version = `php -v 2>/dev/null`;
    my $php_major_version;
    my $cpanel_php_handler;

    if ( $php_version =~ m{ \A PHP \s (\S+) \s }xms ) {
        $php_version = $1;
    }
    else {
        $php_version = 'Unknown';
    }

    if ( $php_version =~ /^(\d)+\./ ) {
        $php_major_version = $1;
    }

    if ( $php_major_version and $is_cpanel == 1 ) {
        if ( open my $file_fh, '<', '/usr/local/apache/conf/php.conf.yaml' ) {
            while ( <$file_fh> ) {
                if ( /^php${php_major_version}:\s(\S+)/ ) {
                    $cpanel_php_handler = $1;
                    last;
                }
            }
            close $file_fh;
        }
    }

    if ( $cpanel_php_handler ) {
        $php_version .= " (handler: $cpanel_php_handler)";
    }

    print_format( 'PHP', $php_version );
}

sub print_apache_info {
    my $apache_version;
    my @apache_binaries = qw( httpd apache2 http2 httpd2 apache );

    for my $apache_binary ( @apache_binaries ) {
        $apache_bin = _find_bin( $apache_binary );
        if ( $apache_bin ) {
            last;
        }
    }

    if ( $apache_bin ) {
        $apache_version = `$apache_bin -v`;
        if ( $apache_version =~ m{ \A Server \s version: \s Apache/(\S+) \s }xms ) {
            $apache_version = $1;
        }
    }
    else {
        $apache_version = 'Unknown';
    }

    print_format( 'Apache', $apache_version );
}

sub mem_rounded {
    my ($mem_size) = @_;
    my $chip_size  = 1;
    my $chip_guess = ($mem_size / 8) - 1;
    while ($chip_guess != 0) {
        $chip_guess >>= 1;
        $chip_size  <<= 1;
    }
    my $mem_round = (int($mem_size / $chip_size) + 1) * $chip_size;
    return $mem_round;
}

sub print_cpu_info {
    my ($model, $mhz) = ();
    my $numcores = 0;
    if ( open my $cpuinfo_fh, '<', '/proc/cpuinfo' ) {
        for my $line ( readline $cpuinfo_fh ) {
            if ( $line =~ /^model name/m ) {
                $line =~ s/^model name\s+:\s+//;
                $line =~ s/\(R\)//g;
                $line =~ s/\(tm\)//g;
                $line =~ s/\s{2,}/ /;
                $line =~ s/\s*\@/ \@/;
                $model = $line;
                chomp $model;
                $numcores++;
            }
            if ( $line =~ /^cpu MHz/m ) {
                $line =~ s/^cpu MHz\s+:\s+//;
                $mhz = $line;
                chomp $mhz;
            }
        }
        close $cpuinfo_fh;
    }
    else {
        return;
    }
    print_format( 'CPU', $model . ' w/ ' . $numcores . ' cores' );
}

sub print_mem_info {
    if ( $^O =~ /freebsd/i ) { 
        my $sysctl        = {}; 
        my $sysctl_output = `/sbin/sysctl -a`;
        foreach my $line ( split( /\n/, $sysctl_output ) ) { 
            if ( $line =~ m/^([^:]+):\s+(.+)\s*$/s ) { 
                $sysctl->{$1} = $2; 
            }
        }

        my $mem_hw       = mem_rounded( $sysctl->{"hw.physmem"} );
        my $mem_inactive = $sysctl->{"vm.stats.vm.v_inactive_count"} * $sysctl->{"hw.pagesize"};
        my $mem_cache    = $sysctl->{"vm.stats.vm.v_cache_count"} * $sysctl->{"hw.pagesize"};
        my $mem_free     = $sysctl->{"vm.stats.vm.v_free_count"} * $sysctl->{"hw.pagesize"};

        my $mem_total = $mem_hw / 1024 / 1024;
        my $mem_avail = int( ( $mem_inactive + $mem_cache + $mem_free ) / 1024 / 1024 );

        print_format( 'Memory', "${mem_total}MB (Free: ${mem_avail}MB)" );
    }   
    else {
        my $in = `free -m`;
        $in =~ /Mem:[\s]+([0-9]+)[\s]+[0-9]+[\s]+([0-9]+)[\s]+[0-9]+[\s]+[0-9]+[\s]+([0-9]+)/;
        my $total = $1; 
        my $free  = $2; 
        my $cache = $3; 

        print_format( 'Memory', "${total}MB (Free: " . ( $free + $cache ) . "MB)" );
    }   
} 

sub print_number_of_accounts {
    my $account_num;

    if ( -f '/etc/trueuserdomains' ) { 
        chomp( $account_num = `sort -u /etc/trueuserdomains | wc -l` );
    }   
    else {
        die '/etc/trueuserdomains missing!';
    }   

    print_format( 'Accounts', $account_num );
}

sub print_dedicated_ipaddrs {
    my $result;
    my ( @usedips, @freeips );

    # From the earlier check, /etc/domainips should exist.
    open( FILE, "/etc/domainips" );
    while (<FILE>) {
        push( @usedips, ' ' . $_ ) if $_ =~ /^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}: /;
    }

    return if ( scalar @usedips == 0 );

    $result = scalar(@usedips) . " Used";

    # Get Free Count if cPanel
    if ( $is_cpanel == 1 ) { 
        my $cmd = `/scripts/ipusage`;
        my @ipusage = split( "\n", $cmd );
        foreach (@ipusage) {
            chomp $_; 
            push( @freeips, $1 ) if $_ =~ /^([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}) $/;
        }
        $result .= " (" . scalar(@freeips) . " Free)";
    }   

    # Tack on the sites in question
    $result .= "\n";
    foreach (@usedips) {
        $result .= $_; 
    }   

    print_format( 'Dedicated IPAddrs', $result );
}

sub print_mysql_db_count {
    my @alldbs = split( "\n", sqlcmd( 'show databases;' ) );
    my @userdbs = grep { !/^(logaholicDB_.+|information_schema|performance_schema|cphulkd|eximstats|horde|leechprotect|mysql|(da_)?roundcube|atmail|admin_appl|psa|phpmyadmin_.+|sitebuilder5)$/ } @alldbs;

    if ( scalar @userdbs > 0 ) {
        print_format( 'MySQL DBs', @alldbs . " (" . @userdbs . " User Created)" );
    }
}

sub sqlcmd {
    my ($cmd) = @_;
    my $result;
    my $wtrfh;
    my $rdrfh;
    my $mysql  = _find_bin( 'mysql' );
    my $passwd = get_mysql_auth();

    my $user = $passwd->{'user'};
    my $pass;

    ## TODO: .my.cnf can use pas, pass, passw, passwo, passwor, and password
    if ( $passwd->{'password'} ) {
        $pass = $passwd->{'password'};
    }
    elsif ( $passwd->{'passwd'} ) {
        $pass = $passwd->{'passwd'};
    }
    elsif ( $passwd->{'pass'} ) {
        $pass = $passwd->{'pass'};
    }

    my $pid = IPC::Open3::open3( $wtrfh, $rdrfh, $rdrfh, $mysql, '-N', '-u', $user, "--password=$pass" );
    print {$wtrfh} "$cmd\n";
    close($wtrfh);
    local $/;
    $result = readline($rdrfh);
    waitpid( $pid, 0 );

    if ( $result =~ /^ERROR.*Access denied/ ) {
        die("Unable to discern correct MySQL user & password - MySQL said:\n$result");
    }
    return $result;
}

sub get_mysql_auth {
    my $data = {};
    if ( $is_cpanel == 1 ) {
        if ( -f "/root/.my.cnf" ) {
            my $mycnf;
            open( FILE, "/root/.my.cnf" );
            while (<FILE>) {
                $mycnf .= $_;
            }
            close(FILE);

            $mycnf =~ /\[client\] (.+?) (\n \s* \[ | $)/xs;

            my @clientblock = split "\n", $1;
            foreach (@clientblock) {
                chomp($_);
                my ( $key, $value ) = split /=/, $_, 2;
                next if !$value;
                if ( $value =~ /^['"](.+)['"]$/ ) {
                    $data->{$key} = $1;
                }
                else {
                    $data->{$key} = $value;
                }
            }
        }
        else {
            die('/root/.my.cnf missing');
        }
    }
    elsif ( $is_plesk == 1 or $is_plesk_smb10 == 1 ) {
        if ( -f "/etc/psa/.psa.shadow" ) {
            my $psa;
            open( FILE, "/etc/psa/.psa.shadow" );
            while (<FILE>) {
                $psa .= $_;
            }
            close(FILE);
            chomp($psa);
            $data->{'user'} = 'admin';
            $data->{'pass'} = $psa;
        }
        else {
            die('/etc/psa/.psa.shadow missing');
        }
    }
    elsif ( $is_ensim == 1 ) {
        my @python_binaries = qw( ensim-python python python2 python2.1 python2.4 );

        for my $python_binary ( @python_binaries ) {
            $python_bin = _find_bin( $python_binary );
            if ( $python_bin ) {
                last;
            }
        }

        local $ENV{'PYTHONPATH'} = '/usr/lib/opcenter/mysql/';
        $data->{'pass'} = `$python_bin -c 'from mysqlbe import *; print read_mysqlpass();'`;
        chomp( $data->{'pass'} );
        $data->{'user'} = 'root';
    }
    elsif ( $is_da == 1 ) {
        if ( -f "/usr/local/directadmin/conf/mysql.conf" ) {
            if ( open( my $fh, '<', "/usr/local/directadmin/conf/mysql.conf" ) ) {
                while ( my $line = <$fh> ) {
                    chomp($line);
                    my ( $key, $value ) = split /=/, $line;
                    next if !$value;
                    $data->{$key} = $value;
                }
                close $fh;
                $data->{'pass'} = $data->{'passwd'};
            }
        }
        else {
            die('/usr/local/directadmin/conf/mysql.conf missing');
        }
    }

    my @passwords = qw( pass passw passwo passwor password passwd ); # does 'passwd' work?
    for my $pass ( @passwords ) {
        if ( $data->{$pass} ) {
            $data->{'pass'} = $data->{$pass};
            last;
        }
    }

    if ( !$data->{'user'} || !$data->{'pass'} ) {
        die('Unable to find MySQL root user or password');
    }
    else {
        return $data;
    }
}

sub print_postgres_db_count {
   if ( _find_bin( 'psql' ) ) {
        if ( find_psql_socket() ) { 
            if ( my $rawsql = psqlcmd("select datname from pg_database") ) { 
                if ( $rawsql =~ /^Postgres Fatal/m ) { return "\n$rawsql" }
                my @alldbs = split( '\n', $rawsql );
                my @userdbs = grep { !/^(postgres|template[0-1])$/ } @alldbs;

                if ( scalar @userdbs > 0 ) {
                    print_format( 'Postgres DBs', @alldbs . " (" . @userdbs . " User Created)" );
                }
            }
        }
    }   
}

sub find_psql_socket {
    my $pid = `lsof -U -a -u postgres -t 2>/dev/null`;
    return $pid;
}

sub psqlcmd {
    my ($cmd) = @_;
    my $result;
    my $rdrfh;
    my $psql   = _find_bin( 'psql' );
    my $passwd = get_psql_auth();

    my $user = $passwd->{'user'};
    my $pass = $passwd->{'pass'};

    local $ENV{'PGUSER'}     = $user;
    local $ENV{'PGPASSWORD'} = $pass;

    # Plesk only authenticates Postgres logins when you're logged in as the postgres user
    # So, we'll just "su" to the postgres user for all panels anyway.
    my $psqlcmd = "cd; $psql -A -F \\| -c '$cmd'";

    #my $pid = IPC::Open3::open3( undef, $rdrfh, undef, 'su', $user, '-c', $psqlcmd );
    my $pid = IPC::Open3::open3( undef, $rdrfh, undef, $psqlcmd );
    local $/;
    $result = readline($rdrfh);
    waitpid( $pid, 0 );
    if ( $result =~ /\n\(([0-9]+) rows\)$/m ) {
        $result =~ /.*\n(([^\n]+\n){$1})\([0-9]+ rows\)$/m;
        $result = $1;
    }
    elsif ( $result =~ /^(psql|su):/ ) {
        if ( $result =~ /FATAL:[\s]+database "$user" does not exist/ ) {

            # It's installed and running, but not configured.  Return undef.
            return undef;
        }
        else {
            chomp $result;
            return ("Postgres Fatal Error - Postgres said: $result");
        }
    }

    return $result;
}

sub get_psql_auth {
    my $data = {};
    if ( $is_cpanel == 1 ) {
        if ( -f "/root/.pgpass" ) {
            my $mycnf;
            open( FILE, "/root/.pgpass" );
            while (<FILE>) {
                $mycnf .= $_;
            }
            close(FILE);
            if ( $mycnf =~ /[^:]+:[^:]+:[^:]+:postgres:([\S]+)/m ) {
                $data->{'user'} = "postgres";
                $data->{'pass'} = $1;
            }
            else {
                $data->{'user'} = "postgres";
                $data->{'pass'} = "";
            }
        }
        else {
            $data->{'user'} = "postgres";
            $data->{'pass'} = "";
        }
    }
    if ( $is_plesk == 1 or $is_plesk_smb10 == 1 ) {
        my $line = sqlcmd("use psa; SELECT admin_login, admin_password FROM DatabaseServers WHERE type='postgresql'");
        my ( $user, $pass ) = split /\s+/, $line;
        $data->{'user'} = $user;
        $data->{'pass'} = $pass;
    }
    else {
        $data->{'user'} = "postgres";
        $data->{'pass'} = "";
    }
    return $data;
}

sub print_custom_apache_modules {
    my @custom;

    # Last reviewed: 08/20/2015
    # Cpanel::Easy::Apache v3.30.0 rev9999
    # EasyApache Basic Profile module list from 'httpd -l' for Apache 2.2 and 2.4 combined
    my @base = qw(
        core.c
        http_core.c
        mod_access_compat.c
        mod_actions.c
        mod_alias.c
        mod_asis.c
        mod_auth_basic.c
        mod_authn_core.c
        mod_authn_default.c
        mod_authn_file.c
        mod_authz_core.c
        mod_authz_default.c
        mod_authz_groupfile.c
        mod_authz_host.c
        mod_authz_user.c
        mod_autoindex.c
        mod_cgi.c
        mod_deflate.c
        mod_dir.c
        mod_env.c
        mod_expires.c
        mod_filter.c
        mod_headers.c
        mod_include.c
        mod_info.c
        mod_log_config.c
        mod_logio.c
        mod_mime.c
        mod_negotiation.c
        mod_proxy_ajp.c
        mod_proxy_balancer.c
        mod_proxy.c
        mod_proxy_connect.c
        mod_proxy_ftp.c
        mod_proxy_http.c
        mod_proxy_scgi.c
        mod_rewrite.c
        mod_setenvif.c
        mod_slotmem_shm.c
        mod_so.c
        mod_socache_dbm.c
        mod_socache_shmcb.c
        mod_ssl.c
        mod_status.c
        mod_suexec.c
        mod_unique_id.c
        mod_unixd.c
        mod_userdir.c
        mod_version.c
        prefork.c
    );

    my $apachem = `$apache_bin -l 2> /dev/null`;
    $apachem =~ /in modules:\s([^\[]+)[\s]?$/m;

    my @mods = split( "\n", $1 );
    foreach (@mods) {
        my $mod = $_; 
        $mod =~ s/^\s+//;
        push( @custom, " " . $mod . "\n" ) unless grep ( /^$mod$/, @base );
    }

    return if !@custom;

    if ( !@custom ) { 
        push( @custom, " -None-\n" );
    }   

    print "\nNon-default Apache Modules:\n";
    for my $module ( @custom ) {
        chomp $module;
        print "$module\n";
    }
}

sub print_custom_php_modules {
    my @custom;

    # Last reviewed: 08/20/2015
    # Cpanel::Easy::Apache v3.30.0 rev9999
    # EasyApache Basic Profile module list from 'php -m' for PHP 5.4
    my @base = qw(
        bcmath
        calendar
        Core
        ctype
        curl
        date
        dom
        ereg
        filter
        ftp
        gd
        hash
        iconv
        imap
        json
        libxml
        mcrypt
        mysql
        mysqlnd
        openssl
        pcre
        PDO
        pdo_mysql
        pdo_sqlite
        Phar
        posix
        Reflection
        session
        SimpleXML
        sockets
        SPL
        sqlite3
        standard
        tokenizer
        xml
        xmlreader
        xmlwriter
        zlib
    );

    # Modules that EasyApache does not support
    my @ignore = qw(
        dbase
        gmp
        ldap
        pcntl
        readline
        shmop
        sysvmsg
        sysvsem
        sysvshm
    );

    # tack them onto @mods so they're disregarded
    push @base, @ignore;

    my $phpm = `php -m 2> /dev/null`;
    if ( $phpm =~ /^\[PHP Modules\]\s([^\[]+)[\s]?$/m ) {
        my @mods = split( "\n", $1 );
        foreach (@mods) {
            my $mod = $_;
            push( @custom, " " . $mod . "\n" ) unless grep ( /^$mod$/, @base );
        }
    }

    if (@custom) {
        @custom = sort @custom;
    }

    return if !@custom;

    print "\nNon-default PHP Modules:\n";
    for my $module ( @custom ) {
        chomp $module;
        print "$module\n";
    }
}

sub print_duplicate_usernames { # And non-unique first 8 characters as required by WHM 11.44+
    if ( -f "/etc/trueuserdomains" ) {
        my %user = ();
        my @dupes = ();
        open( FILE, "/etc/trueuserdomains" );
        while (<FILE>) {
            chomp; 
            if ( m/[^:]+: ([^^\s]+)(?:\^|\s*|$)/ ) {
                $user{$1}{$_} = 1;
                my $first8 = substr( $1, 0, 8 );
                next if length($1) < 8;
                $user{$first8 . " (first 8)"}{$_} = 1;
            }
        }
        close(FILE);

        for (sort(keys %user)) {
            next if scalar (keys(%{$user{$_}})) <= 1;            
            push @dupes, " " x 4 . $_ . ":\n" . " " x 8 . join("\n" . " " x 8, sort(keys(%{$user{$_}})));
        }

        return if scalar @dupes < 1;

        print "\nDuplicate usernames, or whose first 8 characters are not unique:\n";
        print join("\n", @dupes);
        print "\n";
    }
    else {
        die("/etc/trueuserdomains missing!");
    }
}

sub _find_bin {
    my $bin = shift;

    my @bin_search_paths = qw(
        /usr/local/apache/bin
        /etc/apache/bin
        /bin
        /usr/bin
        /usr/sbin
        /usr/local/bin
        /usr/local/sbin
        /usr/libexec
        /usr/local/libexec
    );

    for my $bin_search_path ( @bin_search_paths ) {
        my $bin_tmp = "${bin_search_path}/${bin}";
        if ( -e $bin_tmp ) {
            $bin = $bin_tmp;
            last;
        }
    }

    if ( $bin =~ /\// ) {
        return $bin;
    }
}

sub print_prefixed_panel_info {
    if ( $src_panel_version ) {
        print $prefix . 'VERSION:' . $src_panel_version . "\n";
    }
    elsif ( $dst_panel_version ) {
        print $prefix . 'VERSION:' . $dst_panel_version . "\n";
    }
}

sub print_prefixed_php_info {
    my $php_version = `php -v 2>/dev/null`;

    if ( $php_version =~ m{ (\d{1,2}\.\d{1,2})\. }xms ) {
        $php_version = $1;
        $php_version = $prefix . 'PHP:' . $php_version;
    }
    else {
        $php_version = $prefix . 'PHP:Unknown';
    }

    print "$php_version\n";
}

sub print_prefixed_mysql_info {
    my $mysql_version = `mysql --version`;
    $mysql_version =~ /Ver [0-9]{1,2}\.[0-9]{1,2} Distrib ([0-9]{1,2}\.[0-9]{1,2}\.[0-9]{1,2}[a-z]?), for/;
    $mysql_version = $1 ? $1 : 'Unknown';

    if ( $mysql_version ne 'Unknown' ) {
        my $mysql_version_tmp = $mysql_version;
        $mysql_version_tmp =~ s/\.//g;
        $mysql_version_tmp = substr $mysql_version_tmp, 0, 2;

        if ( $mysql_version_tmp < 41 ) {
            print $prefix . 'MYSQL:' . $mysql_version . ":UNSUPPORTED\n";
        }
        else {
            print $prefix . 'MYSQL:' . "$mysql_version\n";
        }
    }
}

sub print_prefixed_bad_username_info {
    if ( $prefix =~ /^s/ ) {
        if ( -f '/etc/trueuserdomains' ) {
            open my $userdomains_fh, '<', '/etc/trueuserdomains' or die "Could not open /etc/trueuserdomains: $!\n";
            while ( <$userdomains_fh> ) {
                chomp;
                if ( m{ [^:]: \s (.*[\-\._]|test|[0-9]|[A-Z]) }xms ) {
                    print $prefix . 'BADUSER:' . "$_\n";
                    push @badusers, $_;
                }
            }
            close $userdomains_fh;
        }
    }
}

sub print_prefixed_dedicated_ip_addr_info {
    my @source_used_ipaddrs;
    my @cpanel_free_ipaddrs;
    my $cpanel_free_ipaddrs;

    if ( $prefix =~ /^s/ ) {
        if ( open my $domainips_fh, '<', '/etc/domainips' ) {
            while ( <$domainips_fh> ) {
                if ( /^(?:\d+\.\d+\.\d+\.\d+):\s(.*)/ ) {
                    push @source_used_ipaddrs, $1;
                }
            }
            close $domainips_fh;
        }

        print $prefix . 'IPADDRS_USED:' . scalar @source_used_ipaddrs . "\n";

        for my $site ( @source_used_ipaddrs ) {
            chomp $site;
            print $prefix . 'DEDICATED_SITE:' . $site . "\n"
        }
    }
    elsif ( $prefix =~ /^d/ ) {
        if ( open my $command_fh, '-|', '/scripts/ipusage' ) {
            while ( <$command_fh> ) {
                if ( m{ \A (\d+)\.(\d+)\.(\d+)\.(\d+) \s+ \z }xms ) {
                    push @cpanel_free_ipaddrs, $_;
                }
            }
            close $command_fh;
        }

        $cpanel_free_ipaddrs = scalar @cpanel_free_ipaddrs;

        print $prefix . 'IPADDRS_FREE:' . $cpanel_free_ipaddrs . "\n";
    }
}

sub print_prefixed_hosting_types {
    if ( @hosting_type_forward ) {
        for my $line ( @hosting_type_forward ) {
            if ( $line =~ m{ \A (\S+) \s forwarded \s to \s -> \s (\S+) }xms ) {
                print $prefix . 'FORWARDING_DOMAIN:' . $1 . $2 . "\n";
            }
        }
    }

    if ( @hosting_type_nohosting ) {
        for my $domain ( @hosting_type_nohosting ) {
            print $prefix . 'NOHOSTING_DOMAIN:' . $domain . "\n";
        }
    }
}

sub print_prefixed_tomcat_info {
    my $has_tomcat = 0;
    $has_tomcat = `ps aux | grep tomca[t]`;

    if ( $has_tomcat ) {
        print $prefix . 'TOMCAT:' . '1' . "\n";
    }
    else {
        print $prefix . 'TOMCAT:' . '0' . "\n";
    }
}

sub print_prefixed_coldfusion_info {
    my $has_coldfusion = 0;
    $has_coldfusion = `ps aux | grep coldfusio[n]`;

    if ( $has_coldfusion ) {
        print $prefix . 'COLDFUSION:' . '1' . "\n";
    }
    else {
        print $prefix . 'COLDFUSION:' . '0' . "\n";
    }
}

sub print_prefixed_reseller_username_conflicts {
    return if !@plesk_reseller_username_conflicts;

    for my $reseller (@plesk_reseller_username_conflicts) {
        print $prefix . 'RESELLER_CONFLICT:' . $reseller . "\n";
    }
}

sub print_prefixed_user_config_problems {
    if ( $is_da == 1 ) {
        my $configdir = '/usr/local/directadmin/data/users';
        if ( opendir my $dh, $configdir ){
            for ( readdir $dh ) {
                my $user = $_;
                my $configfile = $configdir . "/" . $_ . "/user.conf";
                if ( -f $configfile && open my $fh, '<', $configfile ) {
                    while ( <$fh> ) {
                        if ( m{ ^ (?:[\s\t]+)? (bandwidth|quota) (?:[\s\t]+)? = (?:[\s\t]+)? ["']? (.+?) ['"]? $ }x ) {
                            my $type = uc($1);
                            my $value = $2;
                            next if $value =~ m{ ^ (\d+|unlimited) $ }x;
                            print $prefix . 'BAD_USER_CONFIG:' . $user . ':' . $type . ":\"" . $value . "\"\n";
                        }
                    }
                    close $fh;
                }
            }
            close $dh;
        }
    }
}

sub print_prefixed_php_information {
    my ( $phpini, $memory_limit, $post_max_size, $upload_max_filesize, $date_timezone, $output_buffering ) = (undef) x 6;

    if ( $is_plesk == 1 or $is_plesk_smb10 == 1 or $is_ensim == 1 ) {
        $phpini = '/etc/php.ini';
    }
    elsif ( $is_da == 1 or $is_cpanel == 1 ) {
        $phpini = '/usr/local/lib/php.ini';
    }

    return if !-e $phpini;

    open my $file_fh, '<', $phpini;
    while ( my $line = <$file_fh> ) {
        if ( $line =~ m{ \A (?:[\s\t]+)? memory_limit (?:[\s\t]+)? = (?:[\s\t]+)? ["']? (\d+)M ['"]? }xms ) {
            $memory_limit = $1;
            print $prefix . 'PHPINI_MEMORY_LIMIT:' . $memory_limit . "\n";
        }
        if ( $line =~ m{ \A (?:[\s\t]+)? post_max_size (?:[\s\t]+)? = (?:[\s\t]+)? ["']? (\d+)M ['"]? }xms ) {
            $post_max_size = $1;
            print $prefix . 'PHPINI_POST_MAX_SIZE:' . $post_max_size . "\n";
        }
        if ( $line =~ m{ \A (?:[\s\t]+)? upload_max_filesize (?:[\s\t]+)? = (?:[\s\t]+)? ["']? (\d+)M ['"]? }xms ) {
            $upload_max_filesize = $1;
            print $prefix . 'PHPINI_UPLOAD_MAX_FILESIZE:' . $upload_max_filesize . "\n";
        }
        if ( $line =~ m{ \A date\.timezone (?:\s+)? = (?:\s+)? (?:["'])? ([^/"']+) / ([^/"']+) (?:["'])? (?:\s+)? \z }xms ) {
            $date_timezone = $1 . '/' . $2;
            print $prefix . 'PHPINI_DATE_TIMEZONE:' . $date_timezone . "\n";
        }
        if ( $line =~ m{ \A \s* output_buffering \s* = ["'\s]* ([^"'\s]+) ['"\s]* \z }xms ) {
            $output_buffering = $1;
            print $prefix . 'PHPINI_OUTPUT_BUFFERING:' . $output_buffering . "\n";
        }
    }
    close $file_fh;

}

sub print_prefixed_cpanel_eula_accepted_check {
    return if ( $is_cpanel != 1 );

    my $eula_accepted = 0;
    my @dir_contents;

    if ( -d '/var/cpanel/activate' ) {
        opendir( my $dir_fh, '/var/cpanel/activate' ) or return;
        @dir_contents = grep { /EULACPWHM/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if ( !@dir_contents ) {
        print $prefix . 'EULA:' . '0' . "\n";
    }
    else {
        print $prefix . 'EULA:' . '1' . "\n";
    }
}

sub print_prefixed_mysql_username_conflict_info {
    return if ( $is_plesk == 0 and $is_plesk_smb10 == 0 );

    my ( $user, $domain );
    my %trueuserdomains;
    my %mysql_layout;
    my @seen;

    open my $fh, '<', '/etc/trueuserdomains' or die $!;
    while (<$fh>) {
        chomp;
        ( $domain, $user ) = split /:/, $_;
        $user =~ s/\s+//g;
        $trueuserdomains{$domain} = $user;
    }
    close $fh;

    my $domain_ids_and_names = `mysql -BN psa -e 'select id,name from domains order by id'`;
    my %domain_ids_and_names = split /\s/, $domain_ids_and_names;

    while ( my ( $domain_id, $trueuserdomain ) = each ( %domain_ids_and_names ) ) {
        next if not exists $trueuserdomains{$trueuserdomain};
        my @dbusers = `mysql -BN psa -e '
                   select
                        db_users.login
                   from
                        db_users
                   inner join data_bases on data_bases.id = db_users.db_id
                   inner join domains on data_bases.dom_id = domains.id
                   where
                       data_bases.type = "mysql"
                       and domains.id = $domain_id'`;
        next if !@dbusers;
        $mysql_layout{$trueuserdomain}{$trueuserdomains{$trueuserdomain}} = [ @dbusers ];
    }

    for my $sysuser ( values %trueuserdomains ) {
        next if grep { /^$sysuser$/ } @seen;
        next if grep { /^$sysuser$/ } @badusers; # bad usernames must be renamed anyway
        for my $domain ( keys %mysql_layout ) {
            next if ( exists $mysql_layout{$domain}{$sysuser} ); # Plesk user alice can have a mysql user of the same name
            if ( grep { /^$sysuser$/ } @{ $mysql_layout{$domain}{$trueuserdomains{$domain}} } ) {
                for my $d ( keys %trueuserdomains ) {
                    if ( $trueuserdomains{$d} eq $sysuser ) {
                        print $prefix . 'MYSQL_CONFLICT:' . "${domain}:${sysuser}:${d}\n";
                        push @seen, $sysuser; # avoid checking the same user twice
                        last;
                    }
                }
            }
        }
    }
}

sub print_prefixed_mysql_openfileslimit {
    return if ( $is_cpanel == 0 );
# open_files_limit is auto-scaled with the Transfer Tool in 11.44+, but not when using /scripts/restorepkg
# I want to re-enable this in the future if restorepkg is fixed to do this, but for now we need to keep checking.
#    return if ( version_compare( $cpanel_version, qw( >= 11.44.0.0 ) ) );

    my $open_files_limit = `mysqladmin var | grep open_files_limit | awk '{print \$4}'`;
    chomp $open_files_limit;

    print $prefix . 'MYSQL_OPEN_FILES_LIMIT:' . $open_files_limit . "\n";
}

sub print_prefixed_mysql_skip_networking {
    return if ( $is_cpanel == 0 );

    my $my_cnf = '/etc/my.cnf';

    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A (?:[ \t]+)? (skip[_-]net.*) }xms ) {
                print $prefix . 'MYSQL_SKIP_NETWORKING:1' . "\n";
                last;
            }    
        }    
        close $my_cnf;
    }    
}

sub print_prefixed_mysql_old_style_passwords_info {
    ## if the source is using old_passwords=1 and the cPanel server is using MySQL >= 5.6,
    ## MySQL data may not restore properly

    return if ( $is_cpanel == 1 );

    my $my_cnf = '/etc/my.cnf';

    if ( open my $my_cnf_fh, '<', $my_cnf ) {
        while (<$my_cnf_fh>) {
            chomp( my $line = $_ );
            if ( $line =~ m{ \A (?:[ \t]+)? (old[_-]p.*=(?:[ \t]?)1) }xms ) {
                print $prefix . 'MYSQL_OLD_STYLE_PASSWORDS:1' . "\n";
                last;
            }    
        }    
        close $my_cnf;
    }    
}

sub print_plesk_duplicate_email_users {
    # Plesk allowed creation of duplicate mixed-case email addresses, this reports those.
    # Prior to case FB-75913 mixed-case addresses were skipped entirely, but now we will copy a mixed-case address as all-lowercase if one doesn't already exist
    return if ( $is_plesk == 0 and $is_plesk_smb10 == 0 );

    my $maildir = '/var/qmail/mailnames';
    return if !-d $maildir;

    my %dupes = ();
    my @duplicate_mail_users;
    my @output;

    ## get list of mail domains
    opendir( my $maildir_fh, $maildir );
    my @domains = grep { !/^\.\.?/ } readdir $maildir_fh;
    closedir $maildir_fh;

    my @emailusers;
    my $extra_users;

    ## get list of mail users
    for my $domain (@domains) {
        my $dupes;
        my $users_dir = "${maildir}/${domain}";
        next if !-d $users_dir;

        opendir( my $userdir_fh, $users_dir );
        my @mailusers = grep { !/^\.\.?/ } readdir $userdir_fh;
        closedir $userdir_fh;

        next if !@mailusers;

        my @lowercase_mailusers = map { lc } @mailusers;
        my %seen;
        grep { !$seen{$_}++ } @lowercase_mailusers;

        while (my($k,$v) = each (%seen)) {
            if ($v > 1) {
                for my $user (@mailusers) {
                    if ($user =~ /^${k}$/i) {
                        $dupes .= "$user, ";
                    }
                }
            }
        }

        if ($dupes) {
            $dupes =~ s/,\s$//g;
            $dupes = "[$domain] $dupes";
            push @output, $dupes;
        }
    }

    if (@output) {
        print "\n\nDuplicate email users:\n";
        for my $line (@output) {
            print " $line\n";
        }
    }
}

sub print_reseller_username_conflicts {
    # Case FB-76677 - [Plesk] If a reseller has a domain, copy it instead of making a "psa-reseller-$cpuser.invalid" domain
    # This was addressed by adding --reseller and --no-reseller options to pkgacct-pXa, so we still need to know which reseller usernames conflict with system usernames so they can be handled appropriately.
    return unless ( $is_plesk == 1 or $is_plesk_smb10 == 1 );
    my @plesk_resellers;

    my @reseller_query = `mysql -BN psa -e 'select login, type from clients'`;
    for my $line ( @reseller_query ) {
        chomp $line;
        if ( $line =~ m{ \A (\S+) \s+ reseller \z }xms ) {
            push @plesk_resellers, $1;
        }
    }

    if (@plesk_resellers) {
        for my $reseller (@plesk_resellers) {
            my $test = getpwnam $reseller;
            if ($test) {
                push @plesk_reseller_username_conflicts, $reseller;
            }
        }
    }
}

sub parse_output_file {
    my $file = shift;

    if ( !-f $file ) {
        die "$file does not exist, or is not a regular file\n";
    }

    my ( $has_src, $has_dst );
    my ( $src_php, $dst_php );
    my ( $src_mysql, $dst_mysql );
    my %badusers = ();
    my %baduserconfig = ();
    my ( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free );
    my @sites_on_dedicated_ipaddrs;
    my ( @src_disk_usage, @dst_disk_usage );
    my %forwarding_domains = ();
    my @nohosting_domains;
    my ( $src_tomcat, $dst_tomcat );
    my ( $src_coldfusion, $dst_coldfusion );
    my @reseller_username_conflicts;
    my ( $src_phpini_memory_limit, $dst_phpini_memory_limit );
    my ( $src_phpini_post_max_size, $dst_phpini_post_max_size );
    my ( $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize );
    my ( $src_phpini_date_timezone, $dst_phpini_date_timezone );
    my ( $src_phpini_output_buffering, $dst_phpini_output_buffering );
    my ( @mysql_username_conflicts );
    my $open_files_limit;
    my $skip_networking;
    my $mysql_old_style_passwords;

    open my $file_fh, '<', $file or die "Could not open $file: $!\n";
    while ( <$file_fh> ) {
        chomp;

        ## verify that information exists about both the source and destination
        if ( /^s:/ ) {
            $has_src = 1;
        }
        if ( /^d:/ ) {
            $has_dst = 1;
        }

        ## get source panel type
        if ( m{ \A s:([^:]+): }xms ) {
            $src_panel = $1;
        }

        ## so we can print just 'Plesk' to the customer, and not, say, 'Plesk10SMB'
        if ( $src_panel and $src_panel =~ /^Plesk/ ) {
            $src_panel_noversion = 'Plesk';
        }
        else {
            $src_panel_noversion = $src_panel;
        }

        ## Panel version info
        if ( m{ \A $panel_regex:VERSION:(.*) }xms ) {
            $src_panel_version = $1;
        }
        elsif ( m{ \A d:VERSION:(.*) }xms ) {
            $dst_panel_version = $1;
        }

        ## PHP checks
        if ( m{ \A $panel_regex:PHP:(.*) }xms ) {
            $src_php = $1;
        }
        elsif ( m{ \A d:PHP:(.*) }xms ) {
            $dst_php = $1;
        }

        ## MySQL checks
        if ( m{ \A $panel_regex:MYSQL:(.*) }xms ) {
            $src_mysql = $1;
        }
        elsif ( m{ \A d:MYSQL:(.*) }xms ) {
            $dst_mysql = $1;
        }

        ## Bad username checks
        if ( m{ \A $panel_regex:BADUSER:(.*):\s(.*) \z }xms ) {
            my ( $domain, $user ) = ( $1, $2 );

            ## For Ensim
            if ( $user =~ /\^site(\d+)/ ) {
                $user =~ s/\^site(\d+)//g;
            }
            $badusers{$user} = $domain;
        }

        ## Bad user config checks
        if ( m{ \A $panel_regex:BAD_USER_CONFIG:(.+):(.+):(.+) \z }xms ) {
            my ( $user, $type, $value ) = ( $1, $2, $3 );
            $baduserconfig{$user}{$type} = $value;
        }

        ## IP addr checks
        if ( m{ \A $panel_regex:IPADDRS_USED:(.*) \z }xms ) {
            $src_dedicated_ipaddrs_used = $1;
        }
        elsif ( m{ \A d:IPADDRS_FREE:(.*) }xms ) {
            $dst_ipaddrs_free = $1;
        }

        ## Sites on dedicated IP addrs
        if ( m{ \A $panel_regex:DEDICATED_SITE:(.*) \z }xms ) {
            push @sites_on_dedicated_ipaddrs, $1;
        }

        ## Forwarding domains
        if ( m{ \A s:(?:Plesk(?:8|9|10|10SMB|11|12):FORWARDING_DOMAIN:([^:]+):(.*)) }xms ) {
            my ( $forwarding_from, $forwarding_to ) = ( $1, $2 );
            $forwarding_domains{$forwarding_from} = $forwarding_to;
        }

        ## No hosting domains
        if ( m{ \A s:(?:Plesk(?:8|9|10|10SMB|11|12):NOHOSTING_DOMAIN:([^:]+)) }xms ) {
            my $nohosting_domain = $1;
            push @nohosting_domains, $nohosting_domain;
        }

        ## Tomcat check
        if ( m{ \A $panel_regex:TOMCAT:1 }xms ) {
            $src_tomcat = 1;
        }
        if ( m{ \A d:TOMCAT:1 }xms ) {
            $dst_tomcat = 1;
        }

        ## ColdFusion check
        if ( m{ \A $panel_regex:COLDFUSION:1 }xms ) {
            $src_coldfusion = 1;
        }
        if ( m{ \A d:COLDFUSION:1 }xms ) {
            $dst_coldfusion = 1;
        }

        ## Reseller duplicate username conflict
        # s:Plesk11::RESELLER_CONFLICT:summit
        if ( m{ \A $panel_regex:RESELLER_CONFLICT:(.*) }xms ) {
            push @reseller_username_conflicts, $1;
        }

        if ( m{ \A $panel_regex:PHPINI_MEMORY_LIMIT:(\d+) }xms ) {
            $src_phpini_memory_limit = $1;
        }
        elsif ( m{ \A d:PHPINI_MEMORY_LIMIT:(\d+) }xms ) {
            $dst_phpini_memory_limit = $1;
        }

        if ( m{ \A $panel_regex:PHPINI_POST_MAX_SIZE:(\d+) }xms ) {
            $src_phpini_post_max_size = $1;
        }    
        elsif ( m{ \A d:PHPINI_POST_MAX_SIZE:(\d+) }xms ) {
            $dst_phpini_post_max_size = $1;
        }    
        
        if ( m{ \A $panel_regex:PHPINI_UPLOAD_MAX_FILESIZE:(\d+) }xms ) {
            $src_phpini_upload_max_filesize = $1;
        }
        elsif ( m{ \A d:PHPINI_UPLOAD_MAX_FILESIZE:(\d+) }xms ) {
            $dst_phpini_upload_max_filesize = $1;
        }

        if ( m{ \A $panel_regex:PHPINI_DATE_TIMEZONE:(.*) }xms ) {
            $src_phpini_date_timezone = $1;
        }    
        elsif ( m{ \A d:PHPINI_DATE_TIMEZONE:(.*) }xms ) {
            $dst_phpini_date_timezone = $1;
        }

        if ( m{ \A $panel_regex:PHPINI_OUTPUT_BUFFERING:(.*) }xms ) {
            $src_phpini_output_buffering = $1;
        }    
        elsif ( m{ \A d:PHPINI_OUTPUT_BUFFERING:(.*) }xms ) {
            $dst_phpini_output_buffering = $1;
        }

        ## EULA check
        if ( m{ \A d:EULA:(\d) }xms ) {
            $eula_accepted = $1;
        }

        ## mysql username conflict check
        if ( m{ \A $panel_regex:MYSQL_CONFLICT:(.*)\z }xms ) {
            push @mysql_username_conflicts, $1;
        }

        ## mysql open_files_limit check
        if ( m{ \A d:MYSQL_OPEN_FILES_LIMIT:(\d+)\z }xms ) {
            $open_files_limit = $1;
        }

        ## mysql skip-networking check
        if ( m{ \A d:MYSQL_SKIP_NETWORKING:1 \z }xms ) {
            $skip_networking = 1;
        }

        if ( m{ \A $panel_regex:MYSQL_OLD_STYLE_PASSWORDS:1 \z }xms ) {
            $mysql_old_style_passwords = 1;
        }
    }

    close $file_fh;

    if ( !$has_src or !$has_dst ) {
        die "$file is missing information about the source and/or destination servers\n";
    }

    my $src_disk_usage_ref = \@src_disk_usage;
    my $dst_disk_usage_ref = \@dst_disk_usage;

    if ( $opts->{'es'} == 1 ) {
        print "Hola,\n\nLa evaluacin inicial ha completado. Nuestros resultados son los siguientes:\n\n";
    }
    else {
        print "Hi,\n\nThe pre migration server evaluation is complete. Our findings are as follows:\n\n";
    }

    print_parsed_panel_info();
    print_parsed_eula_info( $eula_accepted );
    print_parsed_php_info( $src_php, $dst_php );
    print_parsed_mysql_info( $src_mysql, $dst_mysql );
    print_parsed_bad_username_info( %badusers );
    print_parsed_bad_user_config_info( %baduserconfig );
    print_parsed_ipaddr_info( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free, @sites_on_dedicated_ipaddrs );
    print_parsed_forwarding_domain_info( %forwarding_domains );
    print_parsed_nohosting_domain_info( @nohosting_domains );
    print_parsed_tomcat_info( $src_tomcat, $dst_tomcat );
    print_parsed_coldfusion_info( $src_coldfusion, $dst_coldfusion );
    print_parsed_reseller_username_conflicts( @reseller_username_conflicts );
    print_parsed_phpini_items( $src_phpini_memory_limit, $dst_phpini_memory_limit,
                               $src_phpini_post_max_size, $dst_phpini_post_max_size,
                               $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize,
                               $src_phpini_date_timezone, $dst_phpini_date_timezone,
                               $src_phpini_output_buffering, $dst_phpini_output_buffering
    );
    print_parsed_mysql_username_conflicts( @mysql_username_conflicts ) if @mysql_username_conflicts;
    print_parsed_mysql_openfileslimit($open_files_limit);
    print_parsed_mysql_skip_networking( $skip_networking );
    print_parsed_mysql_old_style_passwords_info( $dst_mysql, $mysql_old_style_passwords );

}

sub print_parsed_panel_info {
    if ( $opts->{'es'} == 0 ) {
        print "Source: " . $src_panel_version . "\n";
        print "Destination: " . $dst_panel_version . "\n";
    }
    else { #ES
        print "Origen: " . $src_panel_version . "\n";
        print "Destino: " . $dst_panel_version . "\n";
    }
}

sub print_parsed_eula_info {
    if ( $eula_accepted == 0 ) {
        if ( $opts->{'es'} == 0 ) {
            print_header('cPanel End User License Agreement');
            print q{The license agreement has not yet been accepted. Before we can proceed, you must log into WHM as root and accept the license agreement, then complete the initial setup that follows.
};
        }
        else { #ES
            print_header('cPanel Licencia');
            print q{
La licencia de cPanel no ha sido aceptada. Antes de que podamos continuar,
por favor acceda a WHM como root y acepte la licencia, inmediatamente despues
completen la configuracin inicial que sigue.
            };
        }
    }
}

sub print_parsed_php_info {
    my ( $src_php, $dst_php ) = @_;

    my $supported_php_versions = '5.3, 5.4, and 5.5';
    my @php5_minor_available = qw( 3 4 5 );

    my $min_php_minor_supported = shift @php5_minor_available;
    my $max_php_minor_supported = pop   @php5_minor_available;

    my ( $src_php_major, $src_php_minor );
    my ( $dst_php_major, $dst_php_minor );

    if ( $src_php =~ /^(\d+)\.(\d+)/ ) {
        ( $src_php_major, $src_php_minor ) = ( $1, $2 );
    }
    else {
        ( $src_php_major, $src_php_minor ) = ( '0', '0' );
    }

    if ( $dst_php =~ /^(\d+)\.(\d+)/ ) {
        ( $dst_php_major, $dst_php_minor ) = ( $1, $2 );
    }
    else {
        ( $dst_php_major, $dst_php_minor ) = ( '0', '0' );
    }

    my $print_message = 0;
    my $addendum;

    return if ( $src_php eq $dst_php );

    ## we only support PHP 5 at this time

    ## if src php is higher than 5
    if ( $src_php_major > 5 ) {
        $print_message = 1;
        if ( $opts->{'es'} == 0 ) {
            $addendum = qq{
cPanel only supports PHP 5 at this time. Since we cannot change the version of PHP to match that of the $src_panel_noversion server, this message is informational only. No action is required on your part.
            };
        }
        else { #ES
            $addendum = q{
En estos momentos cPanel slo es compatible con PHP 5. Debido a esto no podremos cambiar la versin de PHP para que coincida con la del servidor $src_panel_noversion, este mensaje es para su informacin. No se requiere ninguna accin de usted.
            };
        }
    }
    ## if src php is lower than 5
    elsif ( $src_php_major < 5 or ( $src_php_major == 5 and $src_php_minor < $min_php_minor_supported )) {
        $print_message = 1;
        if ( $opts->{'es'} == 0 ) {
            $addendum = qq{
The versions of PHP do not match. cPanel currently supports PHP 5.3, 5.4, and 5.5. Unfortunately, due to the end-of-life PHP version on the $src_panel_noversion server[1], there may be issues with your sites displaying correctly on the cPanel server. Many features available in PHP <= 5.2 were deprecated in PHP 5.3 and later removed in PHP 5.4 entirely[2].


We can definitely move forward with the migration. However, we would be unable to determine if any of your PHP driven websites may be incompatible with 5.3 or higher. As such its highly recommended that any PHP based websites are updated (if necessary) to be compatible with versions of PHP beyond 5.2.


Additionally, after the migration, we may not be able to provide assistance to issues related to websites which require PHP <= 5.2.


[1] http://php.net/eol.php
[2] http://www.php.net/manual/en/migration53.deprecated.php
            };
        }
        else { #ES
            $addendum = qq{
Las versiones de PHP no son la mismas. cPanel actualmente slo es compatible con PHP 5.3, 5.4, y 5.5. Desafortunadamente, debido a la que la versiones de PHP requeridos han alcanzado el fin de vida. En el servidor $src_panel_noversion [1], puede haber problemas para que los sitios se muestren correctamente en el servidor de cPanel. Muchas de las funciones disponibles en PHP <= 5.2 fueron descontinuados en PHP 5.3 y removidos completamente en PHP 5.4[2].

Podemos continuar con la migracin. Sin embargo, no podremos determinar si alguno de sus sitios web PHP sern incompatibles con 5.3 o mayor. Debido a esto, recomendamos que actualicen sus sitios web para que sean compatibles con versiones de PHP mayores a 5.2.

Adems, despus de la migracin, no podemos proporcionar asistencia con problemas ocurridosn con sitios que requieran PHP <= 5.2.

[1] http://php.net/eol.php
[2] http://www.php.net/manual/en/migration53.deprecated.php
            };
        }
    }

    ## if cPanel isn't using PHP 5 for some reason
    if ( $dst_php_major != 5 ) {
        $print_message = 1;
        if ( $opts->{'es'} == 0 ) {
            $addendum = qq{
cPanel only supports PHP 5 at this time. If you have elected to have us recompile PHP to add support for certain PHP modules, we will be unable to do so unless we can install PHP 5. We currently support PHP $supported_php_versions.


Would you like us to install PHP 5 on the cPanel server? If yes, which version? If no version of specified, we will compile the latest available.


[ ] YES   [ ] NO
            };
        }
        else { #ES
            $addendum = qq{
En estos momentos cPanel slo es compatible con PHP 5. Si usted ha optado que nosotros compilemos PHP para aadir soporte para determinados mdulos de PHP, no podremos hacerlo a menos que podamos instalar PHP 5. Actualmente, soportamos PHP $supported_php_versions.\n\n";

Quieres que instalemos PHP 5 en el servidor cPanel? Si es as, qu versin? Si no especifica una versin, vamos a compilar la ltima versin disponible.

[ ] SI   [ ] NO
            };
        }
    }

    if ( $print_message == 1 ) {
        if ( $opts->{'es'} == 0 ) {
            print_header('PHP Versions');
        }
        else { #ES
            print_header('Versiones de PHP');
        }
        print "${src_panel_noversion}: $src_php\n";
        print "cPanel: $dst_php\n";
        print "\n$addendum\n";
    }
}

sub print_parsed_mysql_info {
    my ( $src_mysql, $dst_mysql ) = @_;

    my $print_message = 0;
    my $addendum;

    if ( $src_mysql =~ m{ (.*):UNSUPPORTED }xms ) {
        $src_mysql =~ s/:UNSUPPORTED//g;

        $print_message = 1;
        if ( $opts->{'es'} == 0 ) {
            $addendum = qq{
The $src_panel_noversion server is running MySQL ${src_mysql}. This version is not supported at this time. We can attempt the migration anyway, but you may need to create the databases on the cPanel server, then manually export and import your databases.


Would you like us to proceed with the migration anyway?


[ ] YES  [ ] NO
            };
        }

        if ( $dst_mysql =~ /^4/ ) {
            $addendum .= qq{
The cPanel server is running MySQL 4, which is not supported at this time. Our recommendation would be to upgrade MySQL via WHM >> MySQL Upgrade before we proceed further.

            };
        }
    }

    if ( $print_message == 1 ) {
        if ( $opts->{'es'} == 0 ) {
            print_header('MySQL Versions');
        }
        else { #ES
            print_header('Versiones MySQL');
            $addendum = qq{
El servidor $src_panel_noversion est utiliza MySQL ${src_mysql}. Esta versin no es soportado en estos momentos. Podemos intentar continuar con la migracin, pero usted tendra que crear las bases de datos en el servidor de cPanel, despues manualmente exportar e importar sus bases de datos.

Quieres que procedamos con la migracin?

[ ] SI   [ ] NO
            };
        }
        print "${src_panel_noversion}: $src_mysql\n";
        print "cPanel: $dst_mysql\n";
        print "\n$addendum\n";
    }
}

sub print_parsed_bad_username_info {
    my %badusers = @_;

    return if ! %badusers;
    
    # get panel version. print how to change username based on panel version

    if ( $opts->{'es'} == 0 ) {
        print_header('Incompatible Usernames');
        print qq{
Usernames were found on the $src_panel_noversion server that are not compatible with cPanel servers. You will need to rename those users before we can copy them. A list of these users is as follows:


USERNAME: DOMAIN
};
    }
    else { #ES
        print_header('Malos nombres de usuario');
        print "Los nombres de usuario que se encuentran en el servidor de $src_panel_noversion no son compatibles con los servidores de cPanel. Usted tendr que cambiar el nombre de los usuarios antes de poder copiarlos. La lista de estos usuarios son:\n\n";
        print "NOMBRE DE USUARIO: DOMINIO\n";
    }
    
    for my $domain ( sort keys %badusers ) {
        print "${domain}: $badusers{$domain}\n";
    }
 
    if ( $opts->{'es'} == 0 ) {
        print_username_change_info();
    }
    else {
        print_username_change_info_ES();
    }
}

sub print_parsed_bad_user_config_info {
    my %baduserconfig = @_;
    return if ! %baduserconfig;
    if ( $opts->{'es'} == 0 ) {
        print_header('User configuration issues');
        print qq{
Some user configuration problems were found on the $src_panel_noversion server that may cause failues during the transfer process.  You will need to correct these configuration issues before we can copy these users.  A list of these users and configuration problems is as follows:

USERNAME: PROBLEM DESCRIPTION

};
    }
    else { #ES
        print_header('Problemas de configuracion de usuarios');
        print qq{
Hemos encontrado algunos problemas de configuracin en el servidor de $src_panel_noversion que pueden causar problemas durante el proceso de transferencia. Ustedes necesitaran corregir estos problemas de configuracin antes de que podamos copiar estos usuarios. La lista de usuarios y los problemas de configuracin son los siguientes:

USUARIO: DESCRIPCION

};
    }
    my %problem = (
        'QUOTA_EN' => 'The user\'s "Total Disk Space(MB)" value must be numeric, with no suffix added such as "MB" or "GB". The current value is: ',
        'QUOTA_ES' => 'El valor del usuario "Total Disk Space(MB)" debe ser numerico sin ningn sufijo agregado como "MB" o "GB". El valor actual es: ',
        'BANDWIDTH_EN' => 'The user\'s "Bandwidth (MB)" value must be numeric, with no suffix added such as "MB" or "GB". The current value is: ',
        'BANDWIDTH_ES' => 'El valor del usuario "Bandwidth (MB)" debe ser numerico sin ningn sufijo agregado como "MB" o "GB". El valor actual es: ',
    );
    for my $user ( sort keys %baduserconfig ) {
        for my $type ( sort keys %{$baduserconfig{$user}} ) {
            my $type_lang = $type . ( $opts->{'es'} ? "_ES" : "_EN" );
            print $user . ": " . $problem{$type_lang} . $baduserconfig{$user}{$type} . "\n\n";
        }
    }
}

sub print_reseller_username_change_info {
    # This has only been tested on Plesk 10, 11, and 11.5.
    if ( $opts->{'es'} == 0 ) {
        print q{
1. Log into Plesk as admin
2. Click "Resellers"
3. Click the link under the "Reseller Name" column
4. Click "Change Login Info"
        };
    }
    else { #ES
        print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Resellers"
3. Haga clic en el enlace debajo de la columna "Reseller Name"
4. Haga clic en "Change Login Info"
        };
    }
}

sub print_username_change_info {
    print q{
When renaming the users, please use the following guidelines:

* Use only letters (lowercase only), and numbers if desired
* Users cannot start with a number, or with the string "test"
    };

    if ( $src_panel_noversion =~ /Plesk/ ) {
        print "\n\nYou can change usernames using these steps:\n";

        if ( $src_panel eq 'Plesk8' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Domains"
3. Click on the domain
4. Click on "Setup"
            };
        }
        elsif ( $src_panel eq 'Plesk9' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Domains"
3. Click on the domain
4. Click on "Web Hosting Settings"
            };
        }
        elsif ( $src_panel eq 'Plesk10' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Domains"
3. Click on the domain
4. Click on "Change Hosting Settings"
            };
        }
        elsif ( $src_panel eq 'Plesk10SMB' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Websites & Domains"
3. Click "Website Settings"
4. Change the value in the box labeled "FTP username"
            };
        }
        elsif ( $src_panel eq 'Plesk11' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Domains"
3. Click on the domain
4. Click the "General" tab
5. Click "Change Hosting Settings"
            };
        }
        elsif ( $src_panel eq 'Plesk12' ) {
            print q{
1. Log into Plesk as "admin"
2. Click "Domains"
3. Click on the domain
4. Click the "General" tab
5. Click "Change Hosting Settings"
            };
        }
    }
    elsif ( $src_panel =~ /Ensim/ ) {
        print q{
1. Log into Ensim as "admin"
2. Click "Site Manager"
3. On the line that contains the domain, click the pencil icon to edit
        };
    }
}

sub print_username_change_info_ES { #ES
    print q{
Cuando cambie el nombre de los usuarios, por favor siga las siguientes directivas:

* Utilice solamente letras (solamente minsculas), y nmeros
* Nombres de usuario no pueden comenzar con un nmero o con el string "test"
    };

    if ( $src_panel_noversion =~ /Plesk/ ) {
        print q{
Usted puede cambiar los nombres de los usuarios siguiendo las siguiente instrucciones:
};

        if ( $src_panel eq 'Plesk8' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Domains"
3. Haga clic en el dominio
4. Haga clic en "Setup"
            };
        }    
        elsif ( $src_panel eq 'Plesk9' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Domains"
3. Haga clic en el dominio
4. Haga clic en "Web Hosting Settings"
            };
        }    
        elsif ( $src_panel eq 'Plesk10' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Domains"
3. Haga clic en el dominio
4. Haga clic en "Change Hosting Settings"
            };
        }    
        elsif ( $src_panel eq 'Plesk10SMB' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Websites & Domains"
3. Haga clic en "Website Settings"
4. Cambie el valor en la casilla "FTP username"
            };
        }    
        elsif ( $src_panel eq 'Plesk11' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Domains"
3. Haga clic en el dominio
4. Haga click en la ficha "General"
5. Haga clic en "Change Hosting Settings"
            };
        }    
        elsif ( $src_panel eq 'Plesk12' ) {
            print q{
1. Inicie sesin en Plesk como "admin"
2. Haga clic en "Domains"
3. Haga clic en el dominio
4. Haga click en la ficha "General"
5. Haga clic en "Change Hosting Settings"
            };
        }    
    }    
    elsif ( $src_panel =~ /Ensim/ ) {
        print q{
1. Inicie sesin en Ensim como "admin"
2. Haga clic en "Site Manager"
3. En la lnea que contiene el dominio, haga clic en el icono del lpiz para editar
        };
    }    
}


sub print_parsed_ipaddr_info {
    my ( $src_dedicated_ipaddrs_used, $dst_ipaddrs_free, @sites_on_dedicated_ipaddrs ) = @_;

    if ( $src_dedicated_ipaddrs_used > $dst_ipaddrs_free ) {
        if ( $opts->{'es'} == 0 ) {
            print_header('IP Addresses');
            print qq{
On the $src_panel_noversion server, the following sites are on dedicated IP addresses:

};
        }
        else { #ES
            print_header('Direcciones IP');
            print "En el servidor de $src_panel_noversion, los siguientes sitios tienen direcciones IP dedicadas:\n\n";

        }

        print "\n";
        for my $site ( sort @sites_on_dedicated_ipaddrs ) {
            print "* $site\n";
        }

        if ( $opts->{'es'} == 0 ) {
            print qq{

However, the cPanel server has $dst_ipaddrs_free dedicated IP address(es) available.


If the sites listed above need to be placed on dedicated IP addresses, you may need to contact your server provider about adding more IP addresses to your server.

If you are using cPanel 11.38 or higher on an OS with SNI support (such as CentOS 6), then you may not need any additional IP addresses. Please check with your server provider to be sure.


Do you need us to place those sites on dedicated IP addresses?


[ ] YES   [ ] NO
            };
        }
        else { #ES
            print qq{

Sin embargo, el servidor cPanel tiene $dst_ipaddrs_free IP dedicado(s) disponible(s).


Si los sitios mencionados anteriormente deben ser colocados en direcciones IP dedicadas, puede que usted tenga que ponerse en contacto con su proveedor de servidor acerca de cmo agregar ms direcciones IP a su servidor.

Si est utilizando cPanel 11.38 o mayor en un sistema operativo con soporte SNI (como CentOS 6), entonces puede que no necesite ninguna de las direcciones IP adicionales. Por favor, consulte con su proveedor de servidor para estar seguro.

Necesitas que estos sitios tengan direcciones IP dedicadas?

[ ] SI   [ ] NO
            };
        }
    }
}

sub print_parsed_forwarding_domain_info {
    my %forwarding_domains = @_;

    return if !%forwarding_domains;

    if ( $opts->{'es'} == 0 ) {
        print_header('Forwarding Domains');

        print q{
We cannot transfer the following forwarding domains, as they are not hosting accounts.
You can add them in WHM >> Setup/Edit Domain Forwarding (this requires just 1 additional IP address on the cPanel server if one does not exist already):

};
    }
    else { #ES
        print_header('Dominios reenviar');

        print q{
No podemos transferir los siguientes forwarding domains, ya que no son cuentas de hosting.
Usted puede aadirlos en WHM >> Setup/Edit Domain Forwarding (esto requiere slo 1 direccin IP adicional en el servidor de cPanel si es que uno no existe):

};
    }

    print "\n";
    for my $domain ( sort keys %forwarding_domains ) {
        if ( $opts->{'es'} == 0 ) {
            print "${domain}: forwarded to -> $forwarding_domains{$domain}\n";
        }
        else { #ES
            print "${domain}: remitido a -> $forwarding_domains{$domain}\n";
        }
    }
}

sub print_parsed_nohosting_domain_info {
    my @nohosting_domains = @_;
    return if !@nohosting_domains;

    if ( $opts->{'es'} == 0 ) {
        print_header('No Hosting domains');

        print q{
The following are domains that we have found that do not have a hosting plan.
The cPanel & WHM transfer tools will not be able to transfer these domains.
In order to make them compatible with the transfer tools, please add hosting to these domains:

};
    }
    else { #ES
        print_header('Dominios sin hosting');
        print q{
Los siguientes son dominios que hemos encontrado que no tienen un plan de hosting.
Las herramientas de transferencia de cPanel y WHM no sern capaces de transferir estos dominios.
Con el fin de hacerlos compatibles con las herramientas de transferencia, por favor agregue un plan de hosting a estos dominios:

};
    }

    print "\n";
    for my $domain ( sort @nohosting_domains ) {
        print "* $domain\n";
    }
}

sub print_parsed_tomcat_info {
    my ( $src_tomcat, $dst_tomcat ) = @_;

    if ( $src_tomcat and !$dst_tomcat ) {
        print_header('Tomcat');

        if ( $opts->{'es'} == 0 ) {
            print qq{

Tomcat is installed on the $src_panel server, but not on the cPanel server.

Do you need us to install Tomcat on the cPanel server?


[ ] YES  [ ] NO

            };
        }
        else { #ES
            print qq{

Tomcat est instalado en el servidor $ src_panel, pero no en el servidor cPanel.

Necesiten que instalemos Tomcat en el servidor de cPanel?

[ ] SI   [ ] NO
            };
        }
    }
}

sub print_parsed_coldfusion_info {
    my ( $src_coldfusion, $dst_coldfusion ) = @_;

    if ( $src_coldfusion and !$dst_coldfusion ) {
        print_header('ColdFusion');

        if ( $opts->{'es'} == 0 ) {
            print qq{

ColdFusion appears to be running on the $src_panel server, but not on the cPanel server.

cPanel does not support the installation, configuration, or maintenance of ColdFusion.

If your websites require ColdFusion, they will not work if it is not installed.

If you need assistance with installing ColdFusion, you would need to contact your sysadmin.
            };
        }
        else { #ES
            print qq{
ColdFusion parece estar en ejecucin en el servidor $src_panel, pero no en el servidor cPanel.

cPanel does not support the installation, configuration, or maintenance of ColdFusion.

Si sus pginas web requieren ColdFusion, no van a funcionar si no est instalado.

Si usted necesita ayuda con la instalacin de ColdFusion, usted tendra que ponerse en contacto con su administrador de sistemas.
            };
        }
    }
}

sub print_parsed_reseller_username_conflicts {
    my @reseller_username_conflicts = @_;
    return if !@reseller_username_conflicts;

    @reseller_username_conflicts = sort @reseller_username_conflicts;

    if ( $opts->{'es'} == 0 ) {
        print_header('Reseller Username Conflicts');

        print qq{
Plesk allows duplicate usernames for resellers and system accounts, while cPanel does not.

As such, the following usernames will need to be renamed to something unique before they can be copied:

};
    }
    else { #ES
        print_header('Conflictos de Nombre de usuarios de revendedores');

        print q{
Plesk permite los nombres de usuario duplicados para los revendedores y las cuentas del sistema, mientras que cPanel no lo hace.

Como tal, tendr que ser cambiado a algo nico antes de que se pueden copiar los siguientes nombres de usuario:

};
    }

    for my $reseller (@reseller_username_conflicts) {
        print "* $reseller\n";
    }

    print_reseller_username_change_info();
}

sub print_parsed_mysql_openfileslimit {
    my $open_files_limit = shift or return;

    if ( $open_files_limit < 10_000 ) {
        print_header('MySQL open_files_limit');

        if ( $opts->{'es'} == 0 ) {
            print qq{
On the cPanel server, MySQL's open_files_limit is set to $open_files_limit which may be lower
than what is necessary to successfully copy databases. I recommend increasing this to 10000
and restarting MySQL. If you'd like, we can do this for you by backing up /etc/my.cnf, adding
open_files_limit=10000 to the file, and restarting MySQL.

May we raise the open_files_limit setting for MySQL?

[ ] YES  [ ] NO
            };
        }
        else { #ES
            print q{
Los open_files_limit de MySQL en el servidor cPanel tienen el valor de 1024. Este valor es menos de lo que recomendamos , que puede ser inferior a lo que es necesario copiar correctamente las bases de datos. Recomiendo aumentar esto a 10000 y reiniciar MySQL. Si usted desea, podemos hacerlo para usted antes haramos una copia de /etc/ my.cnf, aadiendo open_files_limit = 10000 para el archivo y reiniciaremos  MySQL.

Podemos aumentar el ajuste de open_files_limit para MySQL?

[ ] SI [ ] NO
            };
        }
    }
}

sub print_parsed_mysql_skip_networking {
    my $skip_networking = shift;
    return if !$skip_networking;

    print_header('MySQL skip-networking');

    if ( $opts->{'es'} == 0 ) {
        print qq{
On the cPanel server, MySQL's skip-networking option is enabled. This can prevent databases
from restoring properly. This option needs to be disabled throughout the migration process.

May we disable MySQL's skip-networking setting on the cPanel server?

[ ] YES  [ ] NO
        };
    }
    else { # ES
        print q{
En el servidor de cPanel, est habilitada la opcin skip-networking de MySQL. Esto puede impedir
que las bases de datos se puedan restaurar correctamente. Esta opcin debe ser deshabitado durante todo el proceso de migracin.

Podemos desactivar la opcin de skip-networking de MySQL en el servidor cPanel?

[ ] SI  [ ] NO
        };
    }
}

sub print_parsed_mysql_old_style_passwords_info {
    my ( $cpanel_mysql_version, $mysql_old_style_passwords ) = @_;
    $cpanel_mysql_version =~ s/\.//g;
    $cpanel_mysql_version = substr $cpanel_mysql_version, 0, 2;

    if ( defined $mysql_old_style_passwords == 1 and $cpanel_mysql_version >= 56 ) {
        if ( $opts->{'es'} == 0 ) {
            print_header('MySQL 5.6 and old-passwords=1');
            print qq{
The ${src_panel_noversion} server is using the "old-passwords=1" option. However, the cPanel server
is using MySQL 5.6. These are not compatible. The only known workarounds at this time are:

1) Set up a cPanel server with MySQL 5.1 or 5.5, OR

2) Disable the old-passwords=1 option for MySQL on the ${src_panel_noversion} server and reapply
all of the MySQL users' passwords. Then verify in the mysql.user contains the new style passwords
for each user.
            };
        }
        else {
            print_header('MySQL 5.6 y old-passwords=1');
            print qq{
El servidor ${src_panel_noversion} est utilizando la opcin "old-passwords=1". Sin embargo,
el servidor cPanel esta usando MySQL 5.6. Estos no son compatibles. Las soluciones conocidas
solamente en este momento son:

1) Configurar un servidor cPanel con MySQL 5.1 o 5.5, o

2) Deshabilitar los old-passwords=1 opcin para MySQL en el servidor ${src_panel_noversion}
y vuelva a aplicar todas las contraseas de los usuarios MySQL. Compruebe en el mysql.user contiene
las nuevas contraseas de estilo para cada usuario.
            };
        }
    }
}

sub print_parsed_phpini_items {
    my ( $src_phpini_memory_limit, $dst_phpini_memory_limit,
         $src_phpini_post_max_size, $dst_phpini_post_max_size,
         $src_phpini_upload_max_filesize, $dst_phpini_upload_max_filesize,
         $src_phpini_date_timezone, $dst_phpini_date_timezone,
         $src_phpini_output_buffering, $dst_phpini_output_buffering
    ) = @_;

    my $addendum;


    if ( $src_phpini_memory_limit and $dst_phpini_memory_limit ) {
        if ( $src_phpini_memory_limit > $dst_phpini_memory_limit ) {
            $addendum .= qq{
memory_limit:

    ${src_panel_noversion}: ${src_phpini_memory_limit}M
    cPanel: ${dst_phpini_memory_limit}M
            };
        }
    }

    if ( $src_phpini_post_max_size and $dst_phpini_post_max_size ) {
        if ( $src_phpini_post_max_size > $dst_phpini_post_max_size ) {
            $addendum .= qq{
post_max_size:

    ${src_panel_noversion}: ${src_phpini_post_max_size}M
    cPanel: ${dst_phpini_post_max_size}M
            };
        }
    }

    if ( $src_phpini_upload_max_filesize and $dst_phpini_upload_max_filesize ) {
        if ( $src_phpini_upload_max_filesize > $dst_phpini_upload_max_filesize ) {
            $addendum .= qq{
upload_max_filesize:

    ${src_panel_noversion}: ${src_phpini_upload_max_filesize}M
    cPanel: ${dst_phpini_upload_max_filesize}M
            };
        }
    }

    if ( $src_phpini_date_timezone and $dst_phpini_date_timezone ) {
        if ( $src_phpini_date_timezone ne $dst_phpini_date_timezone ) {
            $addendum .= qq{
date.timezone:

    ${src_panel_noversion}: ${src_phpini_date_timezone}
    cPanel: ${dst_phpini_date_timezone}
            };
        }
    }

    if ( $src_phpini_output_buffering and $dst_phpini_output_buffering ) {
        if ( $src_phpini_output_buffering ne $dst_phpini_output_buffering ) {
            $addendum .= qq{
output_buffering:

    ${src_panel_noversion}: ${src_phpini_output_buffering}
    cPanel: ${dst_phpini_output_buffering}
            };
        }
    }

    if ($addendum) {
        if ( $opts->{'es'} == 0 ) {
            print_header('php.ini Settings');
            print qq{
We have checked several of the most commonly customized configuration options in php.ini and found some differences.

To ensure that PHP applications function properly on the cPanel server, it is recommended that the settings be the same on both servers.

The differences that we found are listed below:

$addendum

Would you like us to modify php.ini on the cPanel server to use the same configuration settings listed above?


[ ] YES  [ ] NO
            };
        }
        else { #ES
            print_header('Configuracin php.ini');
            print qq{
Hemos revisado varias de las opciones de configuracin ms comnmente personalizados en php.ini y encontramos algunas diferencias.

Para asegurarse de que las aplicaciones PHP funcionan correctamente en el servidor de cPanel, se recomienda que los ajustes sean los mismos en ambos servidores.

Las diferencias encontradas se enumeran a continuacin:

$addendum

Quieres que modifiquemos php.ini en el servidor cPanel utilizar los mismos ajustes de configuracin mencionados anteriormente?

[ ] SI  [ ] NO
            };
        }
    }
}

sub print_htype_fwd {
    return if ( !$is_plesk == 1 and !$is_plesk_smb10 == 1 );

    my @htype_fwd = `mysql psa -Be 'SELECT domains.name, domains.htype AS hosttype, forwarding.redirect AS target FROM domains, forwarding WHERE domains.id = forwarding.dom_id'`;
    if ( @htype_fwd ) {
        for my $line ( @htype_fwd ) {
            chomp $line;
            $line =~ s#/$##g;
            if ( $line =~ m{ \A (\S+) \s (?:std|frm)_fwd \s (\S+) \z }xms ) {
                my $forward = "${1}: forwarded to -> $2";
                push @hosting_type_forward, $forward;
            }
        }
    }

    if ( @hosting_type_forward ) {
        print "\nForwarded domains:\n";
        for my $line ( @hosting_type_forward ) {
            print "$line\n";
        }
    }

}

sub print_htype_none {
    return if ( !$is_plesk == 1 and !$is_plesk_smb10 == 1 );

    my @htype_none = `mysql psa -Be 'SELECT domains.name, domains.htype AS hosting FROM domains WHERE htype = "none"'`;
    if ( @htype_none ) {
        for my $line ( @htype_none ) {
            chomp $line;
            if ( $line =~ m{ \A (\S+) \s+ none \z }xms ) {
                push @hosting_type_nohosting, $1;
            }
        }
    }

    if ( @hosting_type_nohosting ) {
        print "\nNo hosting domains:\n";
        for my $line ( @hosting_type_nohosting ) {
            print "$line\n";
        }
    }
}

sub check_for_ssl_certificates {
    print_header("SSL (for libkeyutils migrations. Ignore any output above\nabout SSL certificates if this is the destination server)");

    my @ssldomains;
    my @dir_contents;
    my $shared_cert_name;

    ## /etc/ssldomains
    if ( -e '/etc/ssldomains' and !-z '/etc/ssldomains' ) {
        open my $file_fh, '<', '/etc/ssldomains';
        while (<$file_fh>) {
            if ( m{ \A ([^:]+):\s \d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3} }xms ) {
                push @ssldomains, $1;
            }
        }
        close $file_fh;
    }

    if (@ssldomains) {
        @ssldomains = sort @ssldomains;
        print "[/etc/ssldomains]\n\n";
        for my $ssldomain (@ssldomains) {
            print "\t$ssldomain\n";
        }
    }

    ## /var/cpanel/userdata/nobody/
    if ( -d '/var/cpanel/userdata/nobody' ) {
        opendir( my $dir_fh, '/var/cpanel/userdata/nobody' );
        @dir_contents = grep { /SSL$/ } readdir $dir_fh;
        closedir $dir_fh;
    }

    if (@dir_contents) {
        @dir_contents = sort @dir_contents;
        print "\n[/var/cpanel/userdata/nobody]\n\n";
        for my $file (@dir_contents) {
            print "\t$file\n";
        }
    }

    ## /var/cpanel/.sharedcrtname
    if ( -f '/var/cpanel/.sharedcrtname' and !-z '/var/cpanel/.sharedcrtname' ) {
        open my $file_fh, '<', '/var/cpanel/.sharedcrtname';
        while (<$file_fh>) {
            $shared_cert_name = $_;
        }
        close $file_fh;
    }

    if ($shared_cert_name) {
        print "\n[/var/cpanel/.sharedcrtname]\n";
        print "\t$shared_cert_name\n";
    }
}

sub check_for_dns_clustering {
    return if !-e '/var/cpanel/useclusteringdns';

    if ( $opts->{'es'} == 0 ) {
        print_header('DNS CLUSTERING (for libkeyutils migrations)');
        print qq{
The following cluster members were found to be configured on this server
(note: the reverse trust relationship is not known, and would need to be
determined by logging into WHM on the cluster server and checking it there):

};
    }
    else { #ES
    }

    my $cluster_dir = '/var/cpanel/cluster/root/config';
    my @dir_contents;
    my @cluster_members;
    my ( $cluster_member_ipaddr, $cluster_member_hostname, $cluster_member_role );

    if ( -d $cluster_dir ) {
        opendir( my $dir_fh, $cluster_dir );
        @dir_contents = grep { !/^\.\.?$/ } readdir $dir_fh;
        closedir $dir_fh;
    }    

    chdir $cluster_dir or return;

    for my $dirent (@dir_contents) {

        # only active cluster members have -dnsrole files
        if ( $dirent =~ m{ \A (\d+\.\d+\.\d+\.\d+)-dnsrole \z }xms ) {
            $cluster_member_ipaddr = $1;

            if ( open my $file_fh, '<', "${cluster_member_ipaddr}.cache" ) {
                my $cache_ref;
                eval 'local $SIG{__DIE__}; local $SIG{__WARN__}; $cache_ref = Storable::fd_retrieve($file_fh);';    # from upcp.static
                close $file_fh;
                if ($cache_ref) {
                    $cluster_member_hostname = $cache_ref->{'host'};
                }    
                close $file_fh;
            }    
            else {
                $cluster_member_hostname = '?'; 
            }    

            if ( !$cluster_member_hostname ) {
                $cluster_member_hostname = '?'; 
            }    

            if ( open my $file_fh, '<', "${cluster_member_ipaddr}-dnsrole" ) {
                while (<$file_fh>) {
                    $cluster_member_role = $_;
                }    
                close $file_fh;
            }    
            else {
                $cluster_member_role = '?'; 
            }    

            push @cluster_members, $cluster_member_hostname . '_cpeval2_' . $cluster_member_ipaddr . '_cpeval2_' . "[${cluster_member_role}]";
        }    
    }    

    ## print sorted output for cluster members, by hostname
    if (@cluster_members) {
        @cluster_members = sort @cluster_members;

        for my $member (@cluster_members) {
            $member =~ s/_cpeval2_/ /g;
            print "\t$member\n";
        }
    }
}

sub print_parsed_mysql_username_conflicts {
    my @mysql_username_conflicts = @_;
    my $count = 1;
    if ( $opts->{'es'} == 0 ) {
        print_header('mysql Username Conflicts');
        print qq{
mysql username conflicts have been found. To fix, please rename the user(s) specified below:

};
    }
    else { #ES
        print_header('conflictos de nombre de usuario mysql');
        print "\nSe han encontrado conflictos con nombre(s) de usuario(s) de mysql. Para solucionarlo, cambie el nombre del usuario(s):\n\n";
    }

    for my $conflict (@mysql_username_conflicts) {
        my ( $domain1, $user, $domain2 ) = split /:/, $conflict;
        # subscription1.test has mysql user "example", but there is a Plesk account named example, owned by example.com
        if ( $opts->{'es'} == 0 ) {
            print "[CONFLICT $count] $domain1 has mysql user \"$user\" (to fix, rename ${domain2}'s \"$user\")\n";
        }
        else { #ES
            print "[CONFLICTO $count] $domain1 tiene el usuario mysql \"$user\" (para corregir, cambie el nombre ${domain2}'s \"$user\")\n";
        }
        $count++;
    }

    if ( $opts->{'es'} == 0 ) {
        print_username_change_info();
    }
    else {
        print_username_change_info_ES();
    }
}

sub check_for_missing_scp {
    my $mysql_output = `scp 2>&1`;
    if ( ! $mysql_output || ! $mysql_output =~ /usage:/i ) {
        print "\n!!! WARNING !!!: 'scp' may be missing (an attempt to run 'scp' did not return 'usage:' string), which could cause remote transfers to fail!\n\n";
    }
}

sub submit_stats_info {
    return if ! ( $src_panel_version || $dst_panel_version );
    my ($panelname, $panelver, $account_num, $RETURN, $status) = (undef) x 5;
    my $submit_host = 'qs.tech.cpanel.net';

    if ( $src_panel_version ) {
        ($panelname, $panelver) = split(/\s/, $src_panel_version);
    }
    if ( $dst_panel_version ) {
        ($panelname, $panelver) = split(/\s/, $dst_panel_version);
    }

    return if ! ( $panelname =~ /Plesk|Ensim|DirectAdmin/ );

    my ($panelmajor, $panelminor) = split(/\./, $panelver);
    return if ! ($panelmajor =~ /^\d+$/);
    $panelminor = $panelminor ? $panelminor : '0';

    if ( -f '/etc/trueuserdomains' ) { 
        chomp( $account_num = `sort -u /etc/trueuserdomains | wc -l` );
    }

    if ( $account_num && $account_num =~ /(\d+)/ ) {
        $account_num = $1;
    }
    else {
        $account_num = '0';
    }

    my $submit = "panelname=" . $panelname . "&panelver=" . $panelmajor . "." . $panelminor . "&numaccount=" . $account_num;
    my $header = "GET /submit.cgi?" . $submit . " HTTP/1.1\r\nHost: " . $submit_host . "\r\n\r\n";
    
    print "\nSubmitting panel stats info... (" . $submit . ")\n";
    local $SIG{'ALRM'} = sub { print "Submit time-out.\n"; return (); };
    alarm 10;

    my $sock = IO::Socket::INET->new(
        PeerAddr => $submit_host,
        PeerPort => '80',
        Proto    => 'tcp',
        Timeout  => 5,
    );

    if ($sock) {
        print $sock $header;
        sysread $sock, $RETURN, 1000;
        close $sock;
    }

    alarm 0;

    $RETURN = $RETURN ? $RETURN : '';

    for ( split /\n/, $RETURN ) {
        tr/\r//d;
        tr/\n//d;
        if ( m{^HTTP/[^ ]+ (2\d\d.*)$} ) {
            $status = 'Submission successful (' . $1 . ')';
            last;
        }
        if ( m{^HTTP/[^ ]+ (401.*)$} ) {
            $status = 'Submission is a duplicate (' . $1 . '). This is OK.';
            last;
        }
        if ( m{^HTTP/[^ ]+ (400.*)$} ) {
            $status = BOLD RED ON_BLACK 'WARNING: Submission attempt failed (' . $1 . '). Please contact ssp-requests@cpanel.net with this ticket ID and paste this stats submission output into the notes.';
            last;
        }
        if ( m{^HTTP/[^ ]+ (.*)$} ) {
            $status = BOLD RED ON_BLACK 'WARNING: Submission returned unknown status (' . $1 . '). Please contact ssp-requests@cpanel.net with this ticket ID and paste this stats submission output into the notes.';
            last;
        }
    }
    $status = $status ? $status : BOLD RED ON_BLACK 'WARNING: Submission did not return any status code!  Blocked by firewall?  Is our server down?!  We want these stats!';
    print $status. "\n";
}

sub get_ticket {
    return $opts->{'cpmigticket'} if defined($opts->{'cpmigticket'});
    my $ticket;
    if ( exists $ENV{HISTFILE} && $ENV{HISTFILE} =~ /ticket.(\d{7,10})$/ ) {
        $ticket = $1;
        print "Detected ticket number " . $ticket . "\n";
    }
    if ( ! $ticket || $ticket !~ /^\d{7,10}$/ ) {
        print "Unable to auto-detect valid migration ticket number, please enter a valid ticket number (7 to 10 digits) or leave blank to skip: ";
        chomp($ticket = <STDIN>);
        if ( $ticket =~ /^\d{7,10}$/ ) {
            return $ticket;
        }
        else {
            print "Ticket number is not 7-10 digits.  Skipping.\n";
            return 0;
        }
    } else {
        return $ticket;
    }
}

sub check_for_hacked_server_touchfile {
    my $docdir = '/usr/share/doc';
    return if !-d $docdir;

    opendir( my $fh, $docdir ) or return;
    # .cp.jeff.2014-04-09_10.5.40.209_1234567
    my @touchfiles = grep { /^\.cp\.([^\d]+)\.(\d{4}-\d{2}-\d{2})_([^_]+)_(\d+)$/ } readdir $fh;
    closedir $fh;

    return if scalar @touchfiles == 0;
    return 1;
}

sub auto_create_keypair {
    return unless $is_cpanel;
    my ($user, $ticket) = @_;
    return if ! $user;
    return if ! $ticket;
    my $privkey_file = "/root/.ssh/id_" . $user;
    my $pubkey_file = $privkey_file . ".pub";
    my $create_key = 0;
    if ( ! -f $privkey_file ) {
        $create_key = 1;
    }
    if ( ! -f $pubkey_file ) {
        $create_key = 1;
    }
    if ( check_for_hacked_server_touchfile() ) {
        print "Hacked server touch-file found, NOT auto-creating SSH keypair for migration.\n";
        return;
    } else {
        if ( $create_key ) {
            create_cpmig_keypair($user, $ticket);
        } else {
            print "Existing cpmig SSH key pair detected at " . $privkey_file ."\n";
        }
    }
}

sub create_cpmig_keypair {
    my ($user, $ticket) = @_;
    return if ! $user;
    return if ! $ticket;
    print "\n";
    my $privkey_file = "/root/.ssh/id_" . $user;
    my $pubkey_file = $privkey_file . ".pub";
    my $create_key = 0;
    if ( ! -f $privkey_file ) {
        $create_key = 1;
    }
    if ( ! -f $pubkey_file ) {
        $create_key = 1;
    }
    if ( $create_key ) {
        print "-- Attempting to add a new SSH key pair at " . $privkey_file . "\n";
        if ( system("ssh-keygen", "-q", "-t", "rsa", "-N", "", "-C", "cPanel migration services ticket " . $ticket, "-f", $privkey_file) >= 1 ) {
            print "-- Failed to add SSH key pair. Consult any errors above for potential reasons for this.\n";
            return;
        }
    }
    my $pubkey;
    if ( open my $pubkey_fh, '<', $pubkey_file ) {
        while (<$pubkey_fh>) {
            if (/^(ssh.*${ticket})$/) {
                $pubkey = $1;
            }            
        }
        close $pubkey_fh;
        if ( $pubkey ) {
            print "-- SSH public key found at: " . $pubkey_file . "\n";
            print "-- Copy/paste the entire command below on the SOURCE server to create a cpmig user and authorize the SSH key for login:\n";
            # This used the gzipped, base64-encoded contents of createuser.pl
            # export CPUSER="${user}" CPTICKET="${ticket}" PUBKEY="${pubkey}"; cat << END_OF_CREATEUSER | tr -d '\\\\\\n' | base64 -d | gzip -d | perl
            print << "END_OF_COMMAND";
#### BEGIN COPY BELOW ####
curl -s https://cpeval.cpanel.net/cpeval2 | perl - --create-user --cpmiguser="${user}" --cpmigticket="${ticket}" --cpmigkey="${pubkey}"
#### END COPY ABOVE ####
END_OF_COMMAND
        }
        else {
            print "-- SSH public key found at " . $pubkey_file . " but it does not appear to contain the ticket key I am looking for.  Check the contents, remove both ticket key files if necessary, and run this again.\n";
            return;
        }
    } else {
            print "-- Unable to open " . $pubkey_file . "\n";
            return;
    }
}

sub create_cpmig_user {
    print "\n";

    my $fail = 0;
    foreach my $test ( qw( cpmigticket cpmiguser cpmigkey ) ) {
        if ( ! exists($opts->{$test}) || ( exists($opts->{$test}) && ! $opts->{$test} ) ) {
            print "-- Missing " . $test . "\n";
            $fail = 1;
        }
    }

    die if $fail;

    my $user = $opts->{'cpmiguser'};
    my $ticket = $opts->{'cpmigticket'};
    my $pubkey = $opts->{'cpmigkey'};
    my $password;
    my $expire;
    my @user_pwent;

    if ( @user_pwent = getpwnam( $user ) ) {
        print "-- Found existing " . $user . " account\n";
    } else {
        $expire = strftime "%Y-%m-%d", localtime(time + ( 86400 * 60 )); # Expire 60 days from now
        print "-- Attempting to add account for " . $user . " which will expire on " . $expire . ":\n";
        system("useradd", "-c", "cPanel migration services ticket " . $ticket, "-e", $expire, "-m", $user);
        if ( @user_pwent = getpwnam( $user ) ) {
            print "-- Success!\n";
        } else {
            die "Failed to add account. Consult any errors from 'useradd' above for potential reasons for this.\n";
        }
        print "-- Attempting to add " . $user . " to wheel group (might fail on some systems).\n";
        system("usermod", "-G", "wheel", $user);
        print "-- Attempting to set random password for " . $user . ":\n";
        $password = join('', map +(0..9,'a'..'z','A'..'Z')[rand(10+26*2)], 1..16);
        open( PASSWD, "|-" ) || exec( "chpasswd" ) || die "Failed to execute chpasswd to set password.\n";
        print PASSWD $user . ':' . $password . "\n";
        close PASSWD;
    }

    if ( open PASSWD, "passwd -S ${user} |") {
        my $password_set = 0;
        while (<PASSWD>) {
            if ( m{ \A ${user} \s P.? \s }x || m{ \A Password \s set }x ) {
                $password_set = 1;
                print "-- Password is set.\n";
            }
        }
        close PASSWD;
        die "Password check failed, \"passwd -S " . $user ."\" does not report that password is set.\n" unless $password_set;
    } else {
        die "Failed to execute \"passwd -S " . $user . "\" to check password status.\n";
    }

    my $homedir = $user_pwent[7];
    die "Unable to look up homedir for " . $user . "\n" unless $homedir;
    die "Home directory for " . $user . " does not exist\n" unless -d $homedir;

    my $sshdir = $homedir . "/.ssh";

    if ( ! -d $sshdir ) {
        mkdir $sshdir, 0700;
    }

    die ".ssh directory for " . $user . " could not be created\n" unless -d $sshdir;

    chown $user_pwent[2], $user_pwent[3], $sshdir;
    chmod 0700, $sshdir;

    my $authkeys_file = $sshdir . "/authorized_keys";
    my $have_key = 0;

    if ( open my $authkeys_fh, "<", $authkeys_file ) {
        while ( <$authkeys_fh> ) {
            if ( /^\Q$pubkey\E$/ ) {
                $have_key = 1;
            }
        }
        close $authkeys_fh;
        if ( $have_key ) {
            print "-- SSH key already found in " . $authkeys_file . "\n";
            $have_key = 1;
        }
    }

    if ( ! $have_key ) {
        if ( open my $authkeys_fh, ">>", $authkeys_file ) {
            print $authkeys_fh $pubkey . "\n";
            close $authkeys_fh;
        }
        if ( open my $authkeys_fh, "<", $authkeys_file ) {
            while ( <$authkeys_fh> ) {
                if ( /\Q$pubkey\E$/ ) {
                    $have_key = 1;
                }
            }
            close $authkeys_fh;
            if ( $have_key ) {
                print "-- SSH key successfully added to " . $authkeys_file . "\n";
            } else {
                die "Failed to add SSH key to " . $authkeys_file . "\n";
            }
        }
    }

    chown $user_pwent[2], $user_pwent[3], $authkeys_file;
    chmod 0600, $authkeys_file;

    my $sudoers_include_file = "/etc/sudoers.d/cp_migration_" . $ticket;
    my $sudo_entry = $user . "\tALL=(ALL)\tALL";
    my $have_sudo = 0;

    if ( open my $sudoers_fh, "<", $sudoers_include_file ) {
        while ( <$sudoers_fh> ) {
            if ( /^\Q$sudo_entry\E$/ ) {
                $have_sudo = 1;
            }
        }
        if ( $have_sudo ) {
            print "-- Sudo user entry already found in " . $sudoers_include_file . "\n";
        }
        close $sudoers_fh;
    }

    if ( ! $have_sudo ) {
        if ( open my $sudoers_fh, ">>", $sudoers_include_file ) {
            print $sudoers_fh $sudo_entry . "\n";
            close $sudoers_fh;
        }
        if ( open my $sudoers_fh, "<", $sudoers_include_file ) {
            while ( <$sudoers_fh> ) {
                if ( /^\Q$sudo_entry\E$/ ) {
                    $have_sudo = 1;
                }
            }
            close $sudoers_fh;
            if ( $have_sudo ) {
                print "-- Added sudo entry to " . $sudoers_include_file . "\n";
            } else {
                die "-- Failed to add sudo entry to " . $sudoers_include_file . "\n";
            }
        }
}

    my $sudoers_main_file = "/etc/sudoers";
    my $have_include = 0;

    if ( open my $sudoers_fh, "<", $sudoers_main_file ) {
        while ( <$sudoers_fh> ) {
            if ( m{^#includedir\s+/etc/sudoers\.d$} ) {
                $have_include = 1;
            }
        }
        if ( ! $have_include ) {
            print "!! WARNING: \"#includedir /etc/sudoers.d\" not found in " . $sudoers_main_file . ", this means a sudo entry will need to be manually added to /etc/sudoers for ". $user . ":\n" . $sudo_entry . "\n";
        }
        close $sudoers_fh;
    }

    if ( $password && $expire ) {
        print "-- Copy the following information to the Server Information box in the migration ticket:\n";
        print "#### BEGIN COPY BELOW ####\n";
        print "Migration User Name: " . $user . "\n";
        print "Migration User Password: " . $password . "\n";
        print "Migration User Expiration: " . $expire . "\n";
        print "Migration Ticket Number: " . $ticket . "\n";
        print "#### END COPY ABOVE ####\n";
    } else {
        print "-- A new user was not created this time, so there is no password info to give.\n";
    }

exit 0;
}

sub opts_get {
    my $badopt = 0;
    my %opts = (
        'createkeys'        => 0,
        'createuser'        => 0,
        'cpmigticket'       => undef,
        'cpmiguser'         => undef,
        'cpmigkey'          => undef,
        'es'                => 0,
        'help'              => 0,
        'inputfile'         => undef,
        'full-help'         => 0,
        'updateuserdomains' => 0
    );

    Getopt::Long::GetOptions(
        'create-keys|createkeys'    => \$opts{'createkeys'},
        'create-user|createuser'    => \$opts{'createuser'},
        'cpmigticket=i'             => \$opts{'cpmigticket'},
        'cpmiguser=s'               => \$opts{'cpmiguser'},
        'cpmigkey=s'                => \$opts{'cpmigkey'},
        'debug'                     => \$DEBUG,
        'es'                        => \$opts{'es'},
        'full-help|fullhelp'        => \$opts{'full-help'},
        'inputfile=s'               => \$opts{'inputfile'},
        'updateuserdomains'         => \$opts{'updateuserdomains'},
        'usage|help|h'              => \$opts{'help'}
    ) or $badopt = 1;


    $opts{'inputfile'} = shift @ARGV unless defined($opts{'inputfile'});

    open my $pod_fh, '<', \$pod_data;

    pod2usage( { -exitval => 1, -verbose => 1, -input => $pod_fh } ) if $opts{'help'};
    pod2usage( { -exitval => 1, -verbose => 2, -input => $pod_fh } ) if $opts{'full-help'};
    pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } ) if $badopt;

    if ( @ARGV > 1 ) {
        print STDERR "Too many input file names specified on command line.\n";
        pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } );
    }

    if ( defined($opts{'inputfile'}) && ! -f $opts{'inputfile'} ) {
        print STDERR "Input file does not exist.\n";
        pod2usage( { -exitval => 2, -verbose => 1, -input => $pod_fh } );
    }

    close $pod_fh;
    
    return \%opts;
}
